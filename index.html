<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ELLEN&#39;s BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ELLEN&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ELLEN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ELLEN's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ELLEN's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/14/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Compound｜CToken合约代码详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 11:00:54 / 修改时间：11:04:19" itemprop="dateCreated datePublished" datetime="2023-03-14T11:00:54+08:00">2023-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Compound的CToken合约"><a href="#Compound的CToken合约" class="headerlink" title="Compound的CToken合约"></a>Compound的CToken合约</h1><p>当我们在Compound中存入代币时，Compound就会铸造对应的cToken。</p>
<p>CToken合约只是个基类合约，没有构造函数，并且声明了几个抽象的函数，这些抽象函数由上层合约实现。</p>
<p>上层合约分为两种类型：cEther和CERC20，分别处理ETH和ERC20 Token，ETH对应的cEther合约，Erc20对应cErc20合约。</p>
<p>cEther合约是ETH的cToken的交互入口，CErc20Delegator是Erc20的交互入口。在早期版本中，CErc20是Erc20的交互入口，但后来做了调整，CErc20 移除了构造函数，改为了初始化函数，又增加了 CErc20Delegate 作为其上层合约，而且还增加了 CErc20Delegator 来代理 CToken，作为 cToken 的入口合约。</p>
<p><img src="/../images/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/image-20230314101931675.png" alt="image-20230314101931675"></p>
<p>CToken的主要功能是mint（存款）、redeem（赎回存款）、brorrow（借款）、repayBorrow（还款）、liquidate（清算）。</p>
<h1 id="1-CToken代码详解"><a href="#1-CToken代码详解" class="headerlink" title="1. CToken代码详解"></a>1. CToken代码详解</h1><h2 id="1-1-引入文件"><a href="#1-1-引入文件" class="headerlink" title="1.1 引入文件"></a>1.1 引入文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./ComptrollerInterface.sol&quot;; // Comptroller审计合约借款</span><br><span class="line">import &quot;./CTokenInterfaces.sol&quot;; // cToken接口合约</span><br><span class="line">import &quot;./ErrorReporter.sol&quot;; // 错误报告合约</span><br><span class="line">import &quot;./EIP20Interface.sol&quot;; // EIP20接口合约</span><br><span class="line">import &quot;./InterestRateModel.sol&quot;; // 利率模型合约</span><br><span class="line">import &quot;./ExponentialNoError.sol&quot;; // </span><br></pre></td></tr></table></figure>

<p><strong>ComptrollerInterface.sol</strong></p>
<p>ComptrollerInterface是comptroller合约的方法声明，comptroller合约是一个审计合约，会对一些核心业务进行审计和校验。审计函数主要有：</p>
<ul>
<li>**mintAllowed()**：是否允许存款</li>
<li>**redeemAllowed()**：是否允许取款</li>
<li>**borrowAllow()**：是否允许借款</li>
<li>**repayBorrowAllowed()**：是否允许还款</li>
<li>**liquidateBorrowAllowed()**：是否允许清算</li>
<li>**seizeAllowed()**：是否允许清算抵押物</li>
<li>**transferAllowed()**：是否允许转账</li>
</ul>
<p><strong>EIP20Interface.sol</strong></p>
<p>这个合约声明了Erc20标准的常用方法，比如</p>
<ul>
<li>状态：<code>name()</code> 、<code>symbol() </code>、<code>decimals()</code>、<code>totalSupply() </code>、<code>balanceOf(address owner) </code></li>
<li>授权和代币转移：<code>approve(address spender, uint256 amount)</code>、<code>allowance(address owner, address spender)</code>、<code>transferFrom(address src, address dst, uint256 amount)</code>、<code>transfer(address dst, uint256 amount)</code></li>
<li>事件：<code>Transfer</code>、<code> Approval</code></li>
</ul>
<p><strong>InterestRateModel.sol</strong></p>
<p>这个合约定义了利率模型的接口，但因为声明了一个常量<code>isInterestRateModel</code>用来标明这是一个利率模型合约，所以没用 interface 声明，而用 contract，定义成抽象合约。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: BSD-3-Clause</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @title Compound&#x27;s InterestRateModel Interface</span><br><span class="line">  * @author Compound</span><br><span class="line">  */</span><br><span class="line">abstract contract InterestRateModel &#123;</span><br><span class="line">    // 合约是否是利率模型合约</span><br><span class="line">    bool public constant isInterestRateModel = true;</span><br><span class="line"></span><br><span class="line">    // 获取当前的借款利率</span><br><span class="line">    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);</span><br><span class="line"></span><br><span class="line">		// 获取当前存款利率</span><br><span class="line">    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ExponentialNoError.sol</strong></p>
<p>这个合约实现了一些计算方法，定义了Exp结构体，便于安全的进行精度为1e18的数据运算。</p>
<p><strong>ErrorReporter.sol</strong></p>
<p>跟踪错误代码和故障条件的库。</p>
<h2 id="1-2-初始化函数initialize"><a href="#1-2-初始化函数initialize" class="headerlink" title="1.2 初始化函数initialize"></a>1.2 初始化函数initialize</h2><p>这个方法的作用就是初始化利率、comptroller、利率模型、还有cToken的名称、符号以及精度，还初始化了重入锁变量<code>_notEntered = true;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function initialize(ComptrollerInterface comptroller_, // 审计合约地址</span><br><span class="line">                        InterestRateModel interestRateModel_, // 利率模型地址·</span><br><span class="line">                        uint initialExchangeRateMantissa_, // 初始化汇率</span><br><span class="line">                        string memory name_,</span><br><span class="line">                        string memory symbol_,</span><br><span class="line">                        uint8 decimals_) public &#123;</span><br><span class="line">        // 只能由admin调用此方法，并且这个方法只能调用一次</span><br><span class="line">        require(msg.sender == admin, &quot;only admin may initialize the market&quot;);</span><br><span class="line">        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, &quot;market may only be initialized once&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置初始化利率，初始汇率必须大于零</span><br><span class="line">        initialExchangeRateMantissa = initialExchangeRateMantissa_;</span><br><span class="line">        require(initialExchangeRateMantissa &gt; 0, &quot;initial exchange rate must be greater than zero.&quot;);</span><br><span class="line"></span><br><span class="line">        //设置comptroller，如果_setComptroller返回0，那么代表设置成功</span><br><span class="line">        uint err = _setComptroller(comptroller_);</span><br><span class="line">        require(err == NO_ERROR, &quot;setting comptroller failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化区块数和指数</span><br><span class="line">        accrualBlockNumber = getBlockNumber();</span><br><span class="line">        borrowIndex = mantissaOne;</span><br><span class="line"></span><br><span class="line">        // 设置利率模型</span><br><span class="line">        err = _setInterestRateModelFresh(interestRateModel_);</span><br><span class="line">        require(err == NO_ERROR, &quot;setting interest rate model failed&quot;);</span><br><span class="line"></span><br><span class="line">				// 设置cToken的名称、符号和精确度</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">        decimals = decimals_;</span><br><span class="line"></span><br><span class="line">        // 初始化重入锁</span><br><span class="line">        _notEntered = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-transfer"><a href="#1-3-transfer" class="headerlink" title="1.3 transfer"></a>1.3 transfer</h2><p>校验：<code>src !== dst</code>； 授权的数量</p>
<p>作用：spender将token从src转移到dst。是 <code>transfer</code> 和<code>transferFrom</code>的内部调用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) &#123;</span><br><span class="line">   return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) &#123;</span><br><span class="line">        // Fail if transfer not allowed </span><br><span class="line">        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert TransferComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not allow self-transfers </span><br><span class="line">        if (src == dst) &#123;</span><br><span class="line">            revert TransferNotAllowed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 	获得授权金额</span><br><span class="line">        uint startingAllowance = 0;</span><br><span class="line">        if (spender == src) &#123;</span><br><span class="line">            startingAllowance = type(uint).max;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startingAllowance = transferAllowances[src][spender];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新余额，检查上下溢出</span><br><span class="line">        uint allowanceNew = startingAllowance - tokens;</span><br><span class="line">        uint srcTokensNew = accountTokens[src] - tokens;</span><br><span class="line">        uint dstTokensNew = accountTokens[dst] + tokens;</span><br><span class="line"></span><br><span class="line">        accountTokens[src] = srcTokensNew;</span><br><span class="line">        accountTokens[dst] = dstTokensNew;</span><br><span class="line">        // 如果是第三方授权，更新授权金额</span><br><span class="line">        if (startingAllowance != type(uint).max) &#123;</span><br><span class="line">            transferAllowances[src][spender] = allowanceNew;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        emit Transfer(src, dst, tokens);</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-transferFrom"><a href="#1-4-transferFrom" class="headerlink" title="1.4 transferFrom"></a>1.4 transferFrom</h2><p>作用：第三方转移token，调用transferTokens方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) &#123;</span><br><span class="line">        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-approve"><a href="#1-5-approve" class="headerlink" title="1.5 approve"></a>1.5 approve</h2><p>可见性：external</p>
<p>返回值：bool</p>
<p>作用：调用者授权给spender数量为amount的token使用权，设置transferAllowances的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) override external returns (bool) &#123;</span><br><span class="line">        address src = msg.sender;</span><br><span class="line">        transferAllowances[src][spender] = amount;</span><br><span class="line">        emit Approval(src, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-balanceOfUnderlying"><a href="#1-6-balanceOfUnderlying" class="headerlink" title="1.6 balanceOfUnderlying"></a>1.6 balanceOfUnderlying</h2><p>作用：获取用户的标的资产数量，标的资产也会在交易中产生利息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function balanceOfUnderlying(address owner) override external returns (uint) &#123;</span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateCurrent()&#125;);</span><br><span class="line">        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-7-getAccountSnapshot"><a href="#1-7-getAccountSnapshot" class="headerlink" title="1.7 getAccountSnapshot"></a>1.7 getAccountSnapshot</h2><p>作用：获取用户的余额，以及缓存的汇率。可以更有效地执行流动性检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) &#123;</span><br><span class="line">        return (</span><br><span class="line">            NO_ERROR,</span><br><span class="line">            accountTokens[account],</span><br><span class="line">            borrowBalanceStoredInternal(account),</span><br><span class="line">            exchangeRateStoredInternal()</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-borrowRatePerBlock"><a href="#1-8-borrowRatePerBlock" class="headerlink" title="1.8 borrowRatePerBlock"></a>1.8 borrowRatePerBlock</h2><p>作用：返回当前区块借款利率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function borrowRatePerBlock() override external view returns (uint) &#123;</span><br><span class="line">        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-totalBorrowsCurrent"><a href="#1-9-totalBorrowsCurrent" class="headerlink" title="1.9 totalBorrowsCurrent"></a>1.9 totalBorrowsCurrent</h2><p>作用：返回当前借款总额加上应计利息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function totalBorrowsCurrent() override external nonReentrant returns (uint) &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        return totalBorrows;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-accrueInterest"><a href="#1-10-accrueInterest" class="headerlink" title="1.10 accrueInterest"></a>1.10 accrueInterest</h2><p>作用：计算新利息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function accrueInterest() virtual override public returns (uint) &#123;</span><br><span class="line">        // 检查块是否落后，如果相等代表当前区块已经计算过利息，无需计算，直接返回</span><br><span class="line">        uint currentBlockNumber = getBlockNumber();</span><br><span class="line">        uint accrualBlockNumberPrior = accrualBlockNumber;</span><br><span class="line">        if (accrualBlockNumberPrior == currentBlockNumber) &#123;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 读取资金池余额，借款总额、总储备金、借款指数</span><br><span class="line">        uint cashPrior = getCashPrior();</span><br><span class="line">        uint borrowsPrior = totalBorrows;</span><br><span class="line">        uint reservesPrior = totalReserves;</span><br><span class="line">        uint borrowIndexPrior = borrowIndex;</span><br><span class="line"></span><br><span class="line">        // 如果borrowRate超过最大借款利率，则错误退出</span><br><span class="line">        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);</span><br><span class="line">        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, &quot;borrow rate is absurdly high&quot;);</span><br><span class="line"></span><br><span class="line">        // 计算自上次统计以来经过的块数 </span><br><span class="line">        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;</span><br><span class="line">				// 区块区间内的单位利息</span><br><span class="line">        Exp memory simpleInterestFactor = mul_(Exp(&#123;mantissa: borrowRateMantissa&#125;), blockDelta);</span><br><span class="line">        // 表示总借款在该区间内产生的总利息</span><br><span class="line">        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);</span><br><span class="line">        // 总利息累加到总借款中</span><br><span class="line">        uint totalBorrowsNew = interestAccumulated + borrowsPrior;</span><br><span class="line">        // 根据储备金将部分利息累加到储备金中</span><br><span class="line">        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp(&#123;mantissa: reserveFactorMantissa&#125;), interestAccumulated, reservesPrior);</span><br><span class="line">        // 累加借款指数</span><br><span class="line">        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);</span><br><span class="line">				// 更新上一次统计区块、借款指数、总借款、储备金</span><br><span class="line">        accrualBlockNumber = currentBlockNumber;</span><br><span class="line">        borrowIndex = borrowIndexNew;</span><br><span class="line">        totalBorrows = totalBorrowsNew;</span><br><span class="line">        totalReserves = totalReservesNew;</span><br><span class="line"></span><br><span class="line">        // We emit an AccrueInterest event </span><br><span class="line">        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);</span><br><span class="line"></span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-11-borrowBalanceCurrent"><a href="#1-11-borrowBalanceCurrent" class="headerlink" title="1.11 borrowBalanceCurrent"></a>1.11 borrowBalanceCurrent</h2><p>获取当前借贷金额</p>
<p>内部调用了borrowBalanceStoredInternal方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function borrowBalanceStored(address account) override public view returns (uint) &#123;</span><br><span class="line">        return borrowBalanceStoredInternal(account);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function borrowBalanceStoredInternal(address account) internal view returns (uint) &#123;</span><br><span class="line">        // Get 获取借贷余额和借贷指数 </span><br><span class="line">        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         // 如果借贷余额为0，那么借贷指数也为0</span><br><span class="line">        if (borrowSnapshot.principal == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 计算新贷款额需要用到利率指数，公式如下:</span><br><span class="line">         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex</span><br><span class="line">         */</span><br><span class="line">        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;</span><br><span class="line">        return principalTimesIndex / borrowSnapshot.interestIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-12-exchangeRateCurrent"><a href="#1-12-exchangeRateCurrent" class="headerlink" title="1.12 exchangeRateCurrent"></a>1.12 exchangeRateCurrent</h2><p>获取当前汇率</p>
<p>有三个函数：exchangeRateCurrent、exchangeRateStored、exchangeRateStoredInternal，逐层调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 返回当前汇率，精度1e18</span><br><span class="line">function exchangeRateCurrent() override public nonReentrant returns (uint) &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        return exchangeRateStored();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function exchangeRateStored() override public view returns (uint) &#123;</span><br><span class="line">        return exchangeRateStoredInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 根据cToken的标的资产去计算汇率，这个函数在计算汇率之前不产生利息</span><br><span class="line">function exchangeRateStoredInternal() virtual internal view returns (uint) &#123;</span><br><span class="line">        uint _totalSupply = totalSupply;</span><br><span class="line">        // 如果总供应量_totalSupply等于0，说明还没有cToken被铸造，此时的汇率等于初始汇率initialExchangeRate</span><br><span class="line">        // 如果总供应量_totalSupply不等于0，汇率等于(totalCash + totalBorrows - totalReserves) / totalSupply，即（资金池余额+总借款-总供储备量）/ 总供应量</span><br><span class="line">        if (_totalSupply == 0) &#123;</span><br><span class="line">            return initialExchangeRateMantissa;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint totalCash = getCashPrior();</span><br><span class="line">            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;</span><br><span class="line">            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;</span><br><span class="line"></span><br><span class="line">            return exchangeRate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-13-mint"><a href="#1-13-mint" class="headerlink" title="1.13 mint"></a>1.13 mint</h2><p>存款，之所以叫 mint，是因为该操作会新增 cToken 数量，即 totalSupply 增加了，就等于挖矿了 cToken。该操作会将用户的标的资产转入 cToken 合约中（数据会存储在代理合约中），并根据最新的兑换率将对应的 cToken 代币转到用户钱包地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 提供标的资产到资金池可以获得cToken</span><br><span class="line">function mintInternal(uint mintAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        mintFresh(msg.sender, mintAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function mintFresh(address minter, uint mintAmount) internal &#123;</span><br><span class="line">				// 会检查是否允许铸造</span><br><span class="line">        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert MintComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //校验资金池区块是否当前最新</span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert MintFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal()&#125;);</span><br><span class="line"></span><br><span class="line">         // cToken的标的资产一定会是Erc20 Token或者是ETH。actualMintAmount是收到的标的资产数量</span><br><span class="line">        uint actualMintAmount = doTransferIn(minter, mintAmount);</span><br><span class="line">				// 获取当前汇率去计算可以铸造的cToken, 公式是：当前存款/汇率</span><br><span class="line">        uint mintTokens = div_(actualMintAmount, exchangeRate);</span><br><span class="line"></span><br><span class="line">         // 更新总供应量和账户余额</span><br><span class="line">        totalSupply = totalSupply + mintTokens;</span><br><span class="line">        accountTokens[minter] = accountTokens[minter] + mintTokens;</span><br><span class="line"></span><br><span class="line">        emit Mint(minter, actualMintAmount, mintTokens);</span><br><span class="line">        emit Transfer(address(this), minter, mintTokens);</span><br><span class="line"></span><br><span class="line">        /* We call the defense hook */</span><br><span class="line">        // unused function</span><br><span class="line">        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-14-redeem"><a href="#1-14-redeem" class="headerlink" title="1.14 redeem"></a>1.14 redeem</h2><p>赎回存款，即用 cToken 换回标的资产，会根据最新的兑换率计算能换回多少标的资产。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 用 cToken 换回标的资产，会根据最新的兑换率计算能换回多少标的资产</span><br><span class="line">function redeemInternal(uint redeemTokens) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        redeemFresh(payable(msg.sender), redeemTokens, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同样是赎回存款的函数，与上一个函数不同的是，该函数指定的是标的资产的数量，会根据兑换率算出需要扣减多少 cToken。</span><br><span class="line">function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        // redeemFresh emits redeem-specific logs on errors, so we don&#x27;t need to</span><br><span class="line">        redeemFresh(payable(msg.sender), 0, redeemAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 用 cToken 换回标的资产</span><br><span class="line">     * @param redeemer 要赎回资产的用户地址</span><br><span class="line">     * @param redeemTokensIn 支付的cToken数量</span><br><span class="line">     * @param redeemAmountIn 要获得的标的资产的数量</span><br><span class="line">     */</span><br><span class="line"> //     </span><br><span class="line">function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal &#123;</span><br><span class="line">				// redeemTokensIn和redeemAmountIn必须有一个为0</span><br><span class="line">        require(redeemTokensIn == 0 || redeemAmountIn == 0, &quot;one of redeemTokensIn or redeemAmountIn must be zero&quot;);</span><br><span class="line"></span><br><span class="line">        /* exchangeRate = invoke Exchange Rate Stored() */</span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal() &#125;);</span><br><span class="line"></span><br><span class="line">        uint redeemTokens; // 赎回使用的cToken数量</span><br><span class="line">        uint redeemAmount; // 获得的标的资产数量</span><br><span class="line"></span><br><span class="line">        // 如果用于赎回的cToken大于0，那么计算数量为redeemTokensIn的cToken可以换回多少标的资产</span><br><span class="line">        // 如果用于赎回的cToken等于0，那么计算赎回数量为redeemAmountIn的标的资产要减去多少cToken</span><br><span class="line">        if (redeemTokensIn &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 通过汇率来计算:cToken * 汇率</span><br><span class="line">             *  redeemAmount = redeemTokensIn x exchangeRateCurrent</span><br><span class="line">             */</span><br><span class="line">            redeemTokens = redeemTokensIn;</span><br><span class="line">            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 公式:标的资产/汇率</span><br><span class="line">             *  redeemTokens = redeemAmountIn / exchangeRate</span><br><span class="line">             *  redeemAmount = redeemAmountIn</span><br><span class="line">             */</span><br><span class="line">            redeemTokens = div_(redeemAmountIn, exchangeRate);</span><br><span class="line">            redeemAmount = redeemAmountIn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查看cToken是否允许赎回</span><br><span class="line">        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert RedeemComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查区块</span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert RedeemFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果资金池余额小于赎回的标的资产，报错</span><br><span class="line">        if (getCashPrior() &lt; redeemAmount) &#123;</span><br><span class="line">            revert RedeemTransferOutNotPossible();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line">        // 更新总供应量和用户cToken余额</span><br><span class="line">        totalSupply = totalSupply - redeemTokens;</span><br><span class="line">        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * We invoke doTransferOut for the redeemer and the redeemAmount.</span><br><span class="line">         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.</span><br><span class="line">         *  On success, the cToken has redeemAmount less of cash.</span><br><span class="line">         *  doTransferOut reverts if anything goes wrong, since we can&#x27;t be sure if side effects occurred.</span><br><span class="line">         */</span><br><span class="line">        doTransferOut(redeemer, redeemAmount);</span><br><span class="line"></span><br><span class="line">        /* We emit a Transfer event, and a Redeem event */</span><br><span class="line">        emit Transfer(redeemer, address(this), redeemTokens);</span><br><span class="line">        emit Redeem(redeemer, redeemAmount, redeemTokens);</span><br><span class="line"></span><br><span class="line">        /* We call the defense hook */</span><br><span class="line">        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-15-borrow"><a href="#1-15-borrow" class="headerlink" title="1.15 borrow"></a>1.15 borrow</h2><p>借款，会根据用户的抵押物来计算可借额度，借款成功则将所借资产从资金池中直接转到用户钱包地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 发送抵押物后可以借出标的资产，borrowAmount是要借出的标的资产的数量</span><br><span class="line">function borrowInternal(uint borrowAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        borrowFresh(payable(msg.sender), borrowAmount);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">function borrowFresh(address payable borrower, uint borrowAmount) internal &#123;</span><br><span class="line">       // 是否允许借款操作</span><br><span class="line">        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert BorrowComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查区块</span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert BorrowFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前余额小于借出数量，则报错</span><br><span class="line">        if (getCashPrior() &lt; borrowAmount) &#123;</span><br><span class="line">            revert BorrowCashNotAvailable();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取该用户总借贷金额</span><br><span class="line">        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);</span><br><span class="line">        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;</span><br><span class="line">        uint totalBorrowsNew = totalBorrows + borrowAmount;</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        // 更新用户借款和资金池总借款数据</span><br><span class="line">        accountBorrows[borrower].principal = accountBorrowsNew;</span><br><span class="line">        accountBorrows[borrower].interestIndex = borrowIndex;</span><br><span class="line">        totalBorrows = totalBorrowsNew;</span><br><span class="line"></span><br><span class="line">        doTransferOut(borrower, borrowAmount);</span><br><span class="line"></span><br><span class="line">        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-16-repayBorrow"><a href="#1-16-repayBorrow" class="headerlink" title="1.16 repayBorrow"></a>1.16 repayBorrow</h2><p>还款，当指定还款金额为 -1 时，则表示全额还款，包括所有利息，否则，则会存在利息没还尽的可能，因为每过一个区块就会产生新的利息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 还款，当指定还款金额为 -1 时，则表示全额还款</span><br><span class="line">function repayBorrowInternal(uint repayAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        repayBorrowFresh(msg.sender, msg.sender, repayAmount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        repayBorrowFresh(msg.sender, borrower, repayAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 还款</span><br><span class="line">     * @param payer 收质押物地址</span><br><span class="line">     * @param borrower 借款人地址</span><br><span class="line">     * @param repayAmount 还款金额，为 -1 时，则表示全额还款</span><br><span class="line">     * @return (uint) the actual repayment amount.</span><br><span class="line">     */</span><br><span class="line">    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) &#123;</span><br><span class="line">        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert RepayBorrowComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert RepayBorrowFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	// 借款人借款金额</span><br><span class="line">        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);</span><br><span class="line"></span><br><span class="line">        // 还款金额为 -1 时，则表示全额还款</span><br><span class="line">        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line">        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);</span><br><span class="line"></span><br><span class="line">        // 更新借款数据 </span><br><span class="line">        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;</span><br><span class="line">        uint totalBorrowsNew = totalBorrows - actualRepayAmount;</span><br><span class="line"></span><br><span class="line">        accountBorrows[borrower].principal = accountBorrowsNew;</span><br><span class="line">        accountBorrows[borrower].interestIndex = borrowIndex;</span><br><span class="line">        totalBorrows = totalBorrowsNew;</span><br><span class="line"></span><br><span class="line">        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);</span><br><span class="line"></span><br><span class="line">        return actualRepayAmount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-17-liquidateBorrow"><a href="#1-17-liquidateBorrow" class="headerlink" title="1.17 liquidateBorrow"></a>1.17 liquidateBorrow</h2><p>清算，任何人都可以调用此函数来担任清算人，直接借款人、还款金额和清算的 cToken 资产，清算时，清算人帮借款人代还款，并得到借款人所抵押的等值+清算奖励的 cToken 资产。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @notice 调用者清算借款，扣押的抵押品转移给清算人</span><br><span class="line">     * @param borrower 被清算的借款人</span><br><span class="line">     * @param cTokenCollateral 被清算的资金池</span><br><span class="line">     * @param repayAmount 偿还的标的资产的数额</span><br><span class="line">     */</span><br><span class="line">function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        uint error = cTokenCollateral.accrueInterest();</span><br><span class="line">        if (error != NO_ERROR) &#123;</span><br><span class="line">            revert LiquidateAccrueCollateralInterestFailed(error);</span><br><span class="line">        &#125;</span><br><span class="line">        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal &#123;</span><br><span class="line">        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert LiquidateComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert LiquidateFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) &#123;</span><br><span class="line">            revert LiquidateCollateralFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (borrower == liquidator) &#123;</span><br><span class="line">            revert LiquidateLiquidatorIsBorrower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (repayAmount == 0) &#123;</span><br><span class="line">            revert LiquidateCloseAmountIsZero();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (repayAmount == type(uint).max) &#123;</span><br><span class="line">            revert LiquidateCloseAmountIsUintMax();</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">				// 实际偿还金额actualRepayAmount</span><br><span class="line">        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line"></span><br><span class="line">        // 计算被质押物数量，借款人质押的数量必须大于等于计算出来的实际数量</span><br><span class="line">        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);</span><br><span class="line">        require(amountSeizeError == NO_ERROR, &quot;LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED&quot;);</span><br><span class="line"></span><br><span class="line">        require(cTokenCollateral.balanceOf(borrower) &gt;= seizeTokens, &quot;LIQUIDATE_SEIZE_TOO_MUCH&quot;);</span><br><span class="line">				</span><br><span class="line">				// 如果质押物就是当前cToken，那么调用seizeInternal()</span><br><span class="line">				// 如果质押物不是当前cToken，那么调用cTokenCollateral.seize()</span><br><span class="line">        if (address(cTokenCollateral) == address(this)) &#123;</span><br><span class="line">            seizeInternal(address(this), liquidator, borrower, seizeTokens);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, &quot;token seizure failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     * @notice 将抵押品代币(该市场)转移给清算人</span><br><span class="line">     * @dev 除非在清算过程中被另一个cToken调用，否则将失败。使用msg.sender很关键，作为借用的cToken，而不是参数</span><br><span class="line">     * @param liquidator The account receiving seized collateral</span><br><span class="line">     * @param borrower 质押人</span><br><span class="line">     * @param seizeTokens 被质押的cToken</span><br><span class="line">     * @return 返回0就表示成功</span><br><span class="line">     */</span><br><span class="line">    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) &#123;</span><br><span class="line">        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);</span><br><span class="line"></span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 发送质押物给清算人.</span><br><span class="line">     * @param seizerToken 质押物地址</span><br><span class="line">     * @param liquidator 清算人，接收质押物地址</span><br><span class="line">     * @param borrower 借款人</span><br><span class="line">     * @param seizeTokens 质押物数量</span><br><span class="line">     **/</span><br><span class="line">     </span><br><span class="line">    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal &#123;</span><br><span class="line">        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert LiquidateSeizeComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (borrower == liquidator) &#123;</span><br><span class="line">            revert LiquidateSeizeLiquidatorIsBorrower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 更新借款人数据和清算人数据、汇率、储备金</span><br><span class="line">         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens</span><br><span class="line">         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens</span><br><span class="line">         */</span><br><span class="line">        uint protocolSeizeTokens = mul_(seizeTokens, Exp(&#123;mantissa: protocolSeizeShareMantissa&#125;));</span><br><span class="line">        uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;</span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal()&#125;);</span><br><span class="line">        uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);</span><br><span class="line">        uint totalReservesNew = totalReserves + protocolSeizeAmount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line">        totalReserves = totalReservesNew;</span><br><span class="line">        totalSupply = totalSupply - protocolSeizeTokens;</span><br><span class="line">        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;</span><br><span class="line">        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;</span><br><span class="line"></span><br><span class="line">        /* Emit a Transfer event */</span><br><span class="line">        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);</span><br><span class="line">        emit Transfer(borrower, address(this), protocolSeizeTokens);</span><br><span class="line">        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-18-一些状态变量含义"><a href="#1-18-一些状态变量含义" class="headerlink" title="1.18 一些状态变量含义"></a>1.18 一些状态变量含义</h2><p>exchange rate 汇率</p>
<p>borrow interest rate 借款利率</p>
<p>accrualBlockNumber：上次更新利息的区块数</p>
<p>totalSupply 与cToken数量有关</p>
<p>accountTokens[redeemer]记录用户的cToken数量</p>
<p>totalCash 、totalBorrows 、 totalReserves都与标资产有关</p>
<h1 id="二、其他"><a href="#二、其他" class="headerlink" title="二、其他"></a>二、其他</h1><p>本文章创作时：Latest commit <a target="_blank" rel="noopener" href="https://github.com/compound-finance/compound-protocol/commit/a3214f67b73310d547e00fc578e8355911c9d376">a3214f6</a> on Jun 7, 2022</p>
<p>仓库链接：<a target="_blank" rel="noopener" href="https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol">https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/2618#CToken">https://learnblockchain.cn/article/2618#CToken</a></p>
<p><a target="_blank" rel="noopener" href="https://www.defidaonews.com/media/6662323">https://www.defidaonews.com/media/6662323</a></p>
<p><a target="_blank" rel="noopener" href="https://u.naturaldao.io/be/chapter5/5.8%20DeFi%20%E5%80%9F%E8%B4%B7%E5%B9%B3%E5%8F%B0%20Compound">https://u.naturaldao.io/be/chapter5/5.8%20DeFi%20%E5%80%9F%E8%B4%B7%E5%B9%B3%E5%8F%B0%20Compound</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/17/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CPlatypus%E9%81%AD%E9%81%87%E9%97%AA%E7%94%B5%E8%B4%B7%EF%BC%8C%E6%8D%9F%E5%A4%B1$900%E4%B8%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CPlatypus%E9%81%AD%E9%81%87%E9%97%AA%E7%94%B5%E8%B4%B7%EF%BC%8C%E6%8D%9F%E5%A4%B1$900%E4%B8%87/" class="post-title-link" itemprop="url">攻击事件分析｜Platypus遭遇闪电贷，损失$900万</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-17 12:33:18 / 修改时间：12:43:35" itemprop="dateCreated datePublished" datetime="2023-02-17T12:33:18+08:00">2023-02-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h1><p>2023年2月17日安全公司CertiK Alert发推：AAVE上发生一起闪电贷攻击，导致稳定币交易项目Platypus损失了900万美元的资产。</p>
<p>Twitter: <a target="_blank" rel="noopener" href="https://twitter.com/CertiKAlert/status/1626345868151468033">https://twitter.com/CertiKAlert/status/1626345868151468033</a></p>
<p>分析工具：<a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/ava/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430">https://dashboard.tenderly.co/tx/ava/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430</a></p>
<h1 id="二、事件分析"><a href="#二、事件分析" class="headerlink" title="二、事件分析"></a>二、事件分析</h1><h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>MasterPlatypusV4合约的<code>emergencyWithdraw</code>函数验证出现问题，在检查偿付能力时，只要借来的资产不超过借款限额就会返回true，验证通过后允许用户提取所有质押的资金。</p>
<p>emergencyWithdraw一般是用于紧急情况时提取质押资产。</p>
<h2 id="攻击步骤分析"><a href="#攻击步骤分析" class="headerlink" title="攻击步骤分析"></a>攻击步骤分析</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>攻击者向Platypus USDC资产(LP-USDC)存入了闪电贷获得的4400万USDC，获得了4400万LP-USDC。<br>然后攻击者将4400万LP-USD质押到了MasterPlatypusV4。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>攻击者调用函数<code>borrow()</code>在合约platyputreasure中铸造约4179万 USP。这个金额是没有超过4400万的95%的（4400*95%&#x3D;4180）。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>因为攻击者借入的资产没有超过质押资产95%的上限，所以<code>emergencyWithdraw</code>函数在验证偿付能力<code>isSolvent</code>值时返回为“true”。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CPlatypus%E9%81%AD%E9%81%87%E9%97%AA%E7%94%B5%E8%B4%B7%EF%BC%8C%E6%8D%9F%E5%A4%B1$900%E4%B8%87/image-20230217113542420.png" alt="image-20230217113542420"></p>
<p>而<code>platypusTreasure.isSolven</code>还有第二个返回值，是<code>debtAmount</code>,代表债务总额，值为41,794,533,641,783,253,909,671,999，约4179万。</p>
<p><strong>这里没有验证债务总额<code>debtAmount</code>的值，造成只要<code>isSolvent</code>的返回值<code>solvent=true</code>就可以取出质押资产，这是漏洞产生的主要原因。</strong></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CPlatypus%E9%81%AD%E9%81%87%E9%97%AA%E7%94%B5%E8%B4%B7%EF%BC%8C%E6%8D%9F%E5%A4%B1$900%E4%B8%87/image-20230217121330189.png" alt="image-20230217121330189"></p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>攻击者能够取出之前质押全部4400万枚LP-USDC，调用withdraw移除了流动性，提取出了约4399万的USDC(有手续费损耗)<br>注意，这个时候借出来的4179万USP并没有被收回.</p>
<p>偿还闪电贷，并开始通过Platypus Finance池将之前借出来的4179万USP换成多种资产。</p>
<p>最后Platypus平台的总损失价值约为900万美元的资产。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p><strong>这起事件的漏洞在于<code>emergencyWithdraw</code>函数只检查了债务金额是否达到最大限额，没有检查债务总额。导致只要借入的资产没有超过质押资产95%的上限就可以取出质押的资产，并且原来的借款也没有被扣除。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/14/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/14/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析|MTSG代币_burn烧币</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-14 16:02:13 / 修改时间：16:12:53" itemprop="dateCreated datePublished" datetime="2023-02-14T16:02:13+08:00">2023-02-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、事件背景"><a href="#一、事件背景" class="headerlink" title="一、事件背景"></a>一、事件背景</h1><p>上次分析了BEVO事件，此次的MTSG事件和上一篇文章中的BEVO事件很类似，应该是一些攻击者新找到的漏洞点</p>
<p>交易链接：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0x81bb0c65be5fc1288410f506eda1d092f959a589c9065bc1c83075fd245bb683">https://bscscan.com/tx/0x81bb0c65be5fc1288410f506eda1d092f959a589c9065bc1c83075fd245bb683</a></p>
<p>分析工具：<a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0x81bb0c65be5fc1288410f506eda1d092f959a589c9065bc1c83075fd245bb683">https://phalcon.blocksec.com/tx/bsc/0x81bb0c65be5fc1288410f506eda1d092f959a589c9065bc1c83075fd245bb683</a></p>
<h1 id="二、事件分析"><a href="#二、事件分析" class="headerlink" title="二、事件分析"></a>二、事件分析</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>回顾一下BEVO事件的原因：</p>
<blockquote>
<p>被攻击的原因在于<code>deliver</code>方法，当调用该合约的<code>deliver</code>方法时，会减少代币的总价值，导致计算余额出现了误差，造成储备量与余额的不平衡，攻击者通过<code>skim</code>获利。</p>
</blockquote>
<p>而现在的MTSG事件，漏洞出现在_burn上，通过<code>_tTotal = _tTotal.sub(_value);</code>减少了代币总量，导致计算余额出现误差。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213183651175.png" alt="image-20230213183651175"></p>
<h2 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h2><p>我们来分析一下具体原因</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213183950477.png" alt="image-20230213183950477"></p>
<p>多次burn……</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213184044914.png" alt="image-20230213184044914"></p>
<p>1.攻击者闪电贷了367.5个BNB，是MTSG和BNB池子中BNB数量的10倍，原因是攻击者想要兑换出池子中大部分的MTSG。</p>
<p>2.攻击者通过Pancake用367.5BNB兑换了大约90%池子中MTSG的数量。</p>
<p>3.循环调用<code>MTSG.burn</code>方法</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213183651175.png" alt="image-20230213183651175"></p>
<p>如图上所示，会减少<code>_total</code>的总量，直到最后，攻击者剩余97MTSG，pool中剩下9MTSG</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CMTSG%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213184812999.png" alt="image-20230213184812999"></p>
<p>4.攻击者调用<code>MTSG.sync</code>,导致pool中MTSG和BNB比例失调，攻击者使用自己的97MTSG兑换BNB，将池子池子中大部分的BNB拿走。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/13/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/13/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜BEVO 代币deliver攻击事件分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-13 16:22:10 / 修改时间：16:28:13" itemprop="dateCreated datePublished" datetime="2023-02-13T16:22:10+08:00">2023-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h1><p>北京时间2023年1月31日，在twitter上看到这样一条消息：</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213141240813.png" alt="image-20230213141240813"></p>
<p>BEVO 代币被攻击，总共损失45000美元，导致BEVO 代币的价格下跌了 99%。</p>
<p>有趣的是，这个事件中还出现了抢跑，上演了一幕黑吃黑。</p>
<p>twitter：<a target="_blank" rel="noopener" href="https://twitter.com/peckshield/status/1619996999054667784">https://twitter.com/peckshield/status/1619996999054667784</a></p>
<p>成功交易链接：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d">https://bscscan.com/tx/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d</a></p>
<p>被抢跑交易：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0x581c7674a6adfaa4351422781f6b674e2b7ac0fab0db9d46bfcb559ddd96cff8">https://bscscan.com/tx/0x581c7674a6adfaa4351422781f6b674e2b7ac0fab0db9d46bfcb559ddd96cff8</a></p>
<p>分析工具：</p>
<p><a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d">https://phalcon.blocksec.com/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d">https://dashboard.tenderly.co/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d</a></p>
<h1 id="二、事件分析"><a href="#二、事件分析" class="headerlink" title="二、事件分析"></a>二、事件分析</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>被攻击的原因在于<code>deliver</code>方法，当调用该合约的<code>deliver</code>方法时，会减少代币的总价值，导致计算余额出现了误差，造成储备量与余额的不平衡，攻击者通过<code>skim</code>获利。</p>
<h2 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h2><p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213143457009.png" alt="image-20230213143457009"></p>
<ol>
<li><p>攻击者通过闪电贷获得了192.5 WBNB，并通过Pancake交换出来3,028,774,323,006,137,313 BEVO代币。</p>
</li>
<li><p>调用<code>deliver</code>方法，减少总额<code>_rTotal</code>数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function deliver(uint256 tAmount) public &#123;</span><br><span class="line">        address sender = _msgSender();</span><br><span class="line">        require(!_isExcluded[sender], &quot;Excluded addresses cannot call this function&quot;);</span><br><span class="line">        (uint256 rAmount,,,,,,) = _getValues(tAmount);</span><br><span class="line">        _rOwned[sender] = _rOwned[sender].sub(rAmount);</span><br><span class="line">        _rTotal = _rTotal.sub(rAmount);</span><br><span class="line">        _tFeeTotal = _tFeeTotal.add(tAmount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.调用<code>skim</code>方法，在<code>skim</code>中要查询池子中BEVO的余额，过程中会根据<code>_getRate()</code>方法计算BEVO的价值比率，然后计算出当前余额。</p>
<p>先看<code>_getRate()</code>,计算公式是<code>rSupply.div(tSupply)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function _getRate() private view returns(uint256) &#123;</span><br><span class="line">        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();</span><br><span class="line">        return rSupply.div(tSupply);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213150214342.png" alt="image-20230213150214342"></p>
<p>而从<code>_getCurrentSupply()</code>方法中得出的<code>rSupply</code>就和<code>_rTotal</code>有关，由于<code>deliver</code>导致<code>_rTotal</code>减少，所以<code>rSupply.div(tSupply)</code>的比值<code>currentRate</code>也随之减小。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213151242277.png" alt="image-20230213151242277"></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213151328359.png" alt="image-20230213151328359"></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213151311939.png" alt="image-20230213151311939"></p>
<p>最终的余额是<code>rAmount.div(currentRate)</code>计算出来的，<code>rAmount</code>在执行过程中没有被改变过，所以分子不变分母减小，自然导致了余额变大了。</p>
<p>计算出来余额：<code>6844218532359160336</code>,储备量：<code>2298813336114922094</code>,多出的<code>4545405196244238242</code>就被发给了攻击者。</p>
<p>4.攻击者又调用了一次<code>deliver</code>，将<code>_rototal</code>再减少<code>4545405196244238242</code>，使余额与储备量不一致。然后调用了<code>swap</code>方法获利了337个BNB。除去闪电贷192.5个BNB，攻击者最终获得144.5个BNB，总计45000美元。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这起事件后风波没有停止，后来还出现了其他类似的攻击手法，有的攻击者在bsc链上批量扫描符合要求的代币并实施攻击。</p>
<p>从这次攻击事件来看，金额计算模型设计需要谨慎，避免出现参数可控导致的问题，这是保证项目安全及其重要的部分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/20/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/20/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">默克尔树（Merkle Patricia Tree）详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-20 17:04:48" itemprop="dateCreated datePublished" datetime="2023-01-20T17:04:48+08:00">2023-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-22 17:08:59" itemprop="dateModified" datetime="2023-01-22T17:08:59+08:00">2023-01-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>本文是阅读《深入以太坊智能合约开发》的附录A Merkle Patricia Tree后的知识归纳以及扩展。</p>
<blockquote>
<p>默克尔树（Merkle Patricia Tree）在以太坊中是一种通用的，用来存储键值对的数据结构，可以简称为“MPT”，是字典树Redix tree的变种，也是以太坊的核心算法之一。</p>
<p>MPT对于树中节点的插入、查找、删除操作，这种结构可以提供对数级别的复杂度O(log(N))，所以它是一种相对高效的存储结构。</p>
</blockquote>
<h1 id="二、如何根据键值对构造默克尔树"><a href="#二、如何根据键值对构造默克尔树" class="headerlink" title="二、如何根据键值对构造默克尔树"></a>二、如何根据键值对构造默克尔树</h1><h2 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h2><p>树类型的数据结构，都会有节点的概念，MPT也不例外。</p>
<p>MPT中有三种节点类型：branch、leaf、extension：</p>
<ol>
<li><p><strong>branch（分支）</strong></p>
<ul>
<li>由17个元素组成的元组，格式为：(v0,……,v15,vt)。</li>
<li>其中，v0～v15的元素是以其索引值（0x0~0xf）为路径的子节点数据的keccak256哈希值，如果没有子节点数据则元素为空。</li>
<li>vt为根节点到当前节点的父节点所经过的路径对应的value值，也就是根节点到父节点所经过的路径组成了一个键key，这个key对应的value存在vt里面，如果这个key没有对应的value，那么vt为空。</li>
</ul>
</li>
<li><p><strong>leaf（叶）</strong></p>
<ul>
<li>两个元素组成的元组，格式为：（encodePath,value）</li>
<li>encodedPath为当前节点路径的十六进制前缀编码</li>
<li>value是从根节点到当前节点路径组成的键对应的值</li>
</ul>
</li>
<li><p><strong>extension（扩展）</strong></p>
<ul>
<li>两个元素组成的元组，格式为：（encodePath,key）</li>
<li>encodedPath为当前节点路径的十六进制前缀编码</li>
<li>key为当前节点子节点数据的keccak256哈希值</li>
</ul>
</li>
</ol>
<p>总结一下上述的那一堆概念：</p>
<ul>
<li><p>键值对</p>
</li>
<li><p>extension节点记录着：路径、子节点的哈希值。</p>
</li>
<li><p>leaf节点记录着：路径、vlaue。</p>
</li>
<li><p>branch记录着：以索引值为路径的子节点的哈希值、从根节点到branch的父节点路径组成的键对应的value。</p>
</li>
<li><p>value值在leaf和branch节点中存放，key被拆解开，最终由extension、leaf的encodePath以及branch的索引值组成。</p>
</li>
</ul>
<h2 id="2-2-十六进制前缀编码"><a href="#2-2-十六进制前缀编码" class="headerlink" title="2.2 十六进制前缀编码"></a>2.2 十六进制前缀编码</h2><p>branch和extension元组的第一个元素encodePath就是当前节点路径的十六进制前缀编码（Hex-Pretix Encoding，HP编码）。使用HP编码能够区分节点是扩展结点还是叶子节点。<br>而HP编码，和当前节点类型还有当前路径半字节长度的奇偶有关。</p>
<blockquote>
<p>半字节是4位二进制，即1位16进制。</p>
<p>0xf是半字节，0xff是1字节。</p>
<p>1111是半字节，11111111是1字节。</p>
</blockquote>
<p>共有四种前缀：</p>
<table>
<thead>
<tr>
<th>路径所对应的节点类型</th>
<th>路径长度</th>
<th>二进制数值</th>
<th>十六进制数值</th>
<th>最终前缀（HP前缀）</th>
</tr>
</thead>
<tbody><tr>
<td>Extension</td>
<td>偶数个半字节</td>
<td>0000</td>
<td>0x0</td>
<td>0x00</td>
</tr>
<tr>
<td>Extension</td>
<td>奇数个半字节</td>
<td>0001</td>
<td>0x1</td>
<td>0x1</td>
</tr>
<tr>
<td>leaf</td>
<td>偶数个半字节</td>
<td>0010</td>
<td>0x2</td>
<td>0x20</td>
</tr>
<tr>
<td>leaf</td>
<td>奇数个半字节</td>
<td>0011</td>
<td>0x3</td>
<td>0x2</td>
</tr>
</tbody></table>
<p>所以extension节点有两种前缀：0x00、0x1；leaf有两种前缀：0x20、0x3。</p>
<p>可以看到最终前缀在偶数个半字节0x0、0x2后补了一个0，变成了0x00，0x20，目的是为了凑成整字节，避免出现半字节导致长度不便于合并。</p>
<p>HP前缀需要放在原始路径前面去组成HP编码，实例：</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>节点类型</th>
<th>HP前缀</th>
<th>HP编码</th>
</tr>
</thead>
<tbody><tr>
<td>(0x012345,key)（注：012345长度为偶数）</td>
<td>Extension</td>
<td>0x00 (0000 0000)</td>
<td>(<strong>0x00</strong>012345,key)</td>
</tr>
<tr>
<td>(0x12345,key)（注：12345长度为奇数）</td>
<td>Extension</td>
<td>0x1 (0001)</td>
<td>(<strong>0x1</strong>2345,key)</td>
</tr>
<tr>
<td>(0x0f1cb8,value)（注：0f1cb8长度为偶数）</td>
<td>leaf</td>
<td>0x20 (0010 0000)</td>
<td>(<strong>0x20</strong>0f1cb8,value)</td>
</tr>
<tr>
<td>(0xf1cb8,value)（注：f1cb8长度为奇数）</td>
<td>leaf</td>
<td>0x3 (0011)</td>
<td>(<strong>0x3</strong>f1cb8,value)</td>
</tr>
</tbody></table>
<h2 id="2-3-构造一颗默克尔树"><a href="#2-3-构造一颗默克尔树" class="headerlink" title="2.3 构造一颗默克尔树"></a>2.3 构造一颗默克尔树</h2><p>上面的概念不容易理解，现在我们以下面的例子，一步步来进行树的构造，帮助我们更好的理解：</p>
<blockquote>
<p>我们假设有一组（4个）键值对数据需要用树来存储：</p>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; : ‘puppy’</p>
<p>&lt;64 6f 67 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
<p>为方便解释说明以及阅读，我们把键值对数据的“键”表示为十六进制字符串，“值”则保留为原始字符串。在实际使用时，它们都需要经过特定的编码变换。</p>
</blockquote>
<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><blockquote>
<p>&lt;**6**4 6f&gt; : ‘verb’</p>
<p>&lt;**6**4 6f 67&gt; : ‘puppy’</p>
<p>&lt;**6**4 6f 67 65&gt; : ‘coin’</p>
<p>&lt;**6**8 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>每棵树都有根节点，默克尔树的根节点会保存当前路径和子节点哈希，所以很明显，根节点会是一个extension节点。</p>
<p>上面节点类型介绍了extension格式为：（encodePath,key），encodePath是十六进制的HP编码。分析给出的4个键我们可以得出都是以6开头，后面分为4、8两条路。所以根节点存储的共同路径值为0x6。</p>
<p>由于0x6只有一位，所以路径长度是奇数，节点又是extension类型，所以HP前缀是0x1，组合出来的HP编码：<strong>0x1</strong>6。</p>
<p>所以当前默克尔树如下图：</p>
<img src="../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120151314398.png" alt="image-20230120151314398" style="zoom:50%;" />

<p>HashA代表着子节点的哈希值。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><blockquote>
<p>&lt;6**4** 6f&gt; : ‘verb’</p>
<p>&lt;6**4** 6f 67&gt; : ‘puppy’</p>
<p>&lt;6**4** 6f 67 65&gt; : ‘coin’</p>
<p>&lt;6**8** 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>根节点已经找到，但在根节点后出现了两条路，这个时候需要使用branch来处理这种多条路径的情况。</p>
<p>上文说到，branch由17个元素组成的元组，格式为：(v0,……,v15,vt)。其中，v0～v15是以其索引值（0x0~0xf）为路径的子节点数据的keccak256哈希值，如果没有子节点数据则为空。</p>
<p>这里4和8就是索引值，4、8对应元素是其字节点的哈希值。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120152905919.png" alt="image-20230120152905919"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; : ‘puppy’</p>
<p>&lt;64 6f 67 65&gt; : ‘coin’</p>
<p>&lt;68 <strong>6f 72 73 65&gt; : ‘stallion’</strong></p>
</blockquote>
<p>我们可以观察到，在0x68后只有唯一路径了，即0x6f727356，而value为“stallion”，所以不再分叉的情况下，就不是branch或者extension了，而应该是一个leaf叶节点。</p>
<p>上文提到，leaf节点是两个元素组成的元组，格式为：（encodePath,value），encodedPath为当前节点路径的十六进制前缀编码，value是从根节点到当前节点路径组成的键，所对应的值。</p>
<p>当前节点的路径是0x6f727356，长度是偶数，节点类型是leaf，所以可以得出HP前缀是0x20，HP编码是<strong>0x20</strong>6f727356。所以可得该leaf节点：（0x206f727356,”stallion”）。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120154202691.png" alt="image-20230120154202691"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><blockquote>
<p>&lt;64 **6f**&gt; : ‘verb’</p>
<p>&lt;64 **6f** 67&gt; : ‘puppy’</p>
<p>&lt;64 **6f** 67 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>说完了8，我们再说说4这部分，路径4后面有共同路径6f，6f后才产生null和6两条分叉。</p>
<p>共同路径6f是一个extension节点，extension节点格式不再介绍，开始计算HP编码，6f长度是偶数，又是extension类型，所以HP前缀为0x00，HP编码为<strong>0x00</strong>6f。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120155033149.png" alt="image-20230120155033149"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><blockquote>
<p>&lt;64 6f&gt; <strong>: ‘verb’</strong></p>
<p>&lt;64 6f **6**7&gt; : ‘puppy’</p>
<p>&lt;64 6f **6**7 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>6f后分出了null和6，是多条路径，所以HashD的节点是一个branch节点，6是索引值，索引为6的元素存储着子节点hash；而null是没有的，上文提到：vt为根节点到当前节点的父节点所经过的路径组成的键对应的value。</p>
<p>则代表当前HashD节点该存储从根节点到父节点0x646f组成的键对应的值：’verb’。那么该由HashD的vt保存’verb’。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120160053382.png" alt="image-20230120160053382"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 6**7**&gt; : ‘puppy’</p>
<p>&lt;64 6f 6**7** 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>接下来是共同路径7，一个extension节点，开始计算HP编码，7长度是奇数，又是extension类型，所以HP前缀为0x1，HP编码为<strong>0x1</strong>7。</p>
<p>所以当前默克尔树如下图：</p>
<img src="../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120160420895.png" alt="image-20230120160420895" style="zoom:50%;" />

<h4 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; <strong>: ‘puppy’</strong></p>
<p>&lt;64 6f 67 **6**5&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>7后分出了null和6，是多条路径，与第五步相同，HashF是一个branch节点，索引为6的元素存储子节点哈希，vt存储’puppy’的值</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120160833192.png" alt="image-20230120160833192"></p>
<h4 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; : ‘puppy’</p>
<p>&lt;64 6f 67 6<strong>5&gt; : ‘coin’</strong></p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>好了，现在只剩下一条路径了，表示这最后一个是一个leaf叶子节点，路径为5，路径长度为奇数，索引HP前缀为0x3，HP编码为<strong>0x3</strong>5</p>
<p>所以当前也是最终的默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120161243321.png" alt="image-20230120161243321"></p>
<p>以上就是这棵默克尔树构造的全部过程了，写得很详细，是希望能够为在阅读书籍时没有理顺思路的小伙伴们提供一些帮助。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>从构造过程中我们可以看出，MPT中节点之间，是通过哈希值来确定的。由于哈希值的特性，只要数据有了微小改动，就会导致根节点改变，所以我们可以用树的根节点来代表整个树中数据的状态，这样就不用保存整个树的数据。</p>
<p>在以太坊中，默克尔树有着大量的应用，比如保存和验证系统中的所有账户状态、所有合约的存储状态、区块中的所有交易和所有收据数据的状态等。</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120163214097.png" alt="image-20230120163214097"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/2020/01/27/7c1fcd777d7b">【深度知识】以太坊区块数据结构及以太坊的4棵数</a></p>
<p>《深入以太坊智能合约开发》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/07/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/07/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜RFB一起多次买卖获利分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-07 16:30:00 / 修改时间：16:32:53" itemprop="dateCreated datePublished" datetime="2022-12-07T16:30:00+08:00">2022-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li></li>
</ul>
<h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><p>攻击者：0x5f7db41e2196080f397cdcf8dd58e8adfdaf2ade</p>
<p>攻击合约：0xd5de2914bc6d2f005228a04289e8d518c710a049</p>
<p>交易信息：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a">https://bscscan.com/tx/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a</a></p>
<p>分析工具：</p>
<p><a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a">https://phalcon.blocksec.com/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a/debugger">https://dashboard.tenderly.co/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a/debugger</a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>攻击者获利1.17个BNB。原因是RFB在买入时有一个奖励机制存在漏洞。而攻击者就不断的通过大约20BNB去买入卖出RFB，来触发这个奖励机制。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/image-20221207160733104.png" alt="image-20221207160733104"></p>
<p>我们看奖励机制的核心代码：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L264">https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L264</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/image-20221207160459448.png" alt="image-20221207160459448"></p>
<p>买入RFB时，会用到<code>_transferFrom</code>，执行到最后，如果使用的是WBNB与RFB兑换的pair，就会触发奖励机制<code>randMod</code>。</p>
<p><a target="_blank" rel="noopener" href="https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L417">https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L417</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/image-20221207160904379.png" alt="image-20221207160904379"></p>
<p>这里应该是随机出的数能刚好满足<code>randnum%(10*luckyMultiplier) == 8</code>的条件，然后执行了<code>distributor.withdrawPlazz(buyer, buyBNBamount.mul(90).div(100))</code>，<code>distributor</code>在合约创建是已经确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributor = IDividendDistributor(0x2BD049f1a6A4e93421D93d72AfB7Cb22Cd958c43);</span><br></pre></td></tr></table></figure>

<p>这里的<code>buyer</code>就是<code>0xd5de2914bc6d2f005228a04289e8d518c710a049</code>的地址。</p>
<p>攻击步骤很简单：</p>
<ul>
<li>攻击者通过闪电贷贷出20BNB</li>
<li>不断的买卖RFB，而且没有真正交易成功，最后回滚了交易，但是却能成功的触发奖励。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/30/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/30/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜DPC攻击事件分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-30 13:17:27 / 修改时间：14:16:43" itemprop="dateCreated datePublished" datetime="2022-11-30T13:17:27+08:00">2022-11-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>北京时间2022年9月10日，DPC代币合约遭到黑客攻击，损失超73,614BUSD。</p>
<p>DPC合约是一个ERC20代币合约，除了基本的ERC20代币功能，用户还可以将DPC代币与BUSD进行质押来获得DPC代币奖励。</p>
<p>攻击记录：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x2109bbecB0a563e204985524Dd3DB2F6254AB419">https://bscscan.com/address/0x2109bbecB0a563e204985524Dd3DB2F6254AB419</a></p>
<p>攻击者地址：0xf211fa86cbc60d693d687075b03dff3c225b25c9</p>
<p>攻击合约：0x2109bbecb0a563e204985524dd3db2f6254ab419</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>DPC合约中计算奖励算法存在漏洞，攻击者通过调用<code>claimStakeLp</code>函数取出之前质押的LP，在<code>claimStakeLp</code>中一是没有对每次取出的LP进行数量限制，二是在每次取出LP时计算奖励操作进行了两次，导致计算奖励时会翻倍增加，从而使攻击者有利可图。</p>
<h2 id="攻击步骤如下"><a href="#攻击步骤如下" class="headerlink" title="攻击步骤如下"></a>攻击步骤如下</h2><p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130131625508.png" alt="image-20221130131625508"></p>
<ol>
<li><p>向DPC转移42次BUSD，每次100枚，共计4200BUSD。此步骤调用了dpc合约中的tokenAirdrop方法：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0xb75ca3c3e99747d0e2f6e75a9fbd17f5ac03cebe#code#L1076">https://bscscan.com/address/0xb75ca3c3e99747d0e2f6e75a9fbd17f5ac03cebe#code#L1076</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130122920065.png" alt="image-20221130122920065"></p>
</li>
<li><p>用50枚BUSD兑换DPC，扣除手续费共兑换了约3.63枚。用兑换得到的DPC与约47.4个BUSD进行流动性添加，获得约12.29LP，并将这些流动性进行质押。</p>
</li>
</ol>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130123928518.png" alt="image-20221130123928518"></p>
<ol start="3">
<li>前期做好准备后，到达了关键一步。通过调用DPC合约的claimStakeLp方法，多次取出最低的0.000000000000000001LP来获得奖励。</li>
</ol>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130125826087.png" alt="image-20221130125826087"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function claimStakeLp(address _from ,uint256 Amountwei) public &#123;</span><br><span class="line">        require(Amountwei &gt; 0,&quot;Quantity error&quot;);</span><br><span class="line">        require(_from==msg.sender,&quot;error&quot;);</span><br><span class="line">        require(dpcLp[_from] &gt;= Amountwei ,&quot;Insufficient authorization limit&quot;);</span><br><span class="line">        IERC20(LpContract).transfer(_from,Amountwei);</span><br><span class="line">				// 在这一步，进行奖励的累加，其中还调用了getClaimQuota函数</span><br><span class="line">				// 然而在getClaimQuota内，oldClaimQuota[_from]又重复了一次累加计算</span><br><span class="line">				// 这是导致漏洞的原因</span><br><span class="line">        oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from));</span><br><span class="line"></span><br><span class="line">        dpcLp[_from] = dpcLp[_from].sub(Amountwei);</span><br><span class="line"></span><br><span class="line">        time=currTimeStamp();</span><br><span class="line">        dpcLpTime[_from] = time;</span><br><span class="line"></span><br><span class="line">        dpcLpTotal = dpcLpTotal.sub(Amountwei);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function getClaimQuota(address addr) public view returns (uint256) &#123;</span><br><span class="line">      uint256 ClaimQuota;</span><br><span class="line">      if(dpcAirdrop[addr] &gt; 0 &amp;&amp; dpcLp[addr]&gt;0)&#123;</span><br><span class="line">           uint256 QuotastartTime;</span><br><span class="line">           uint256 limit = 50 * 10**18;</span><br><span class="line">           uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);</span><br><span class="line">           uint256 secondQuota;</span><br><span class="line">           if(getDpcPrice()&gt;0)&#123;</span><br><span class="line">               secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           uint256 limitSecondQuota = limit.div(24*60*60);</span><br><span class="line">           if(secondQuota &gt; limitSecondQuota)&#123;</span><br><span class="line">               secondQuota = limitSecondQuota;</span><br><span class="line">           &#125;</span><br><span class="line">           uint256 nowTime = currTimeStamp();</span><br><span class="line"></span><br><span class="line">           if(dpcLpTime[addr]&gt;ClaimQuotaTime[addr])&#123;</span><br><span class="line">               QuotastartTime = dpcLpTime[addr];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               QuotastartTime = ClaimQuotaTime[addr];</span><br><span class="line">           &#125;</span><br><span class="line">           ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);</span><br><span class="line">           if(ClaimQuota &gt; dpcAirdrop[addr])&#123;</span><br><span class="line">               ClaimQuota = dpcAirdrop[addr];</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">           ClaimQuota = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      // 这里进行了一次相加</span><br><span class="line">      ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]);</span><br><span class="line"></span><br><span class="line">      return ClaimQuota;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.获利后，调用claimDpcAirdrop方法，这次获得奖励约20,602 DPC，后续又兑换为 75,664 BUSD</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130125057699.png" alt="image-20221130125057699"></p>
<p>后续攻击者又重复之前的一些步骤，继续获利。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130125229810.png" alt="image-20221130125229810"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>合约代码需要进行多次审查</li>
<li>针对DPC中出现的漏洞，最好对每次取出的代币数量进行一定的限制，计算奖励时也不要出现这种多次累加的情况。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/" class="post-title-link" itemprop="url">攻击事件分析｜AurumNodePool合约遭受攻击</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-23 16:15:36 / 修改时间：17:16:49" itemprop="dateCreated datePublished" datetime="2022-11-23T16:15:36+08:00">2022-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2022年11月23日，AurumNodePool合约遭受漏洞攻击。攻击者通过该漏洞获得约50个BNB，大约$14,538.04。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><strong>交易</strong>：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782">https://bscscan.com/tx/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782</a></p>
<p><strong>攻击者地址</strong>：0x6903499751f973052155df339116b6c6b24ac24b</p>
<p><strong>攻击合约</strong>：0x3d743b2f760A431CC20047CB5c7758c9a8860D6b</p>
<p><strong>分析工具</strong>：<a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782">https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782</a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>每日奖励值rewardPerDay变量可以随意设置。</p>
<p>可以看代码：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L578">https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L578</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeRewardPerNode</span>(<span class="params">uint256 _rewardPerDay</span>) external &#123;        </span><br><span class="line">        rewardPerDay = _rewardPerDay;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到调用changeRewardPerNode就可以设置rewardPerDay的值，攻击者将这个值设置的非常大。</p>
<p>然后调用claimNodeReward方法，或使用getNodeReward方法计算奖励，结果计算出来的奖励值也非常大，之后攻击者提取了节点奖励。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/image-20221123160822165.png" alt="image-20221123160822165"></p>
<p>getNodeReward：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L504">https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L504</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getNodeReward(NodeEntity memory node) internal view returns (uint256) &#123;</span><br><span class="line">        return rewardPerDay * (block.timestamp - node.lastClaimTime) / 86400;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>可以看到getNodeReward里面计算奖励时使用的就是可被利用的rewardPerDay。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/image-20221123161313087.png" alt="image-20221123161313087"></p>
<p>详细步骤拆分：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>from</th>
<th>to</th>
<th>value</th>
<th>input</th>
<th>out</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>* CALL</td>
<td>0x69（攻击者）</td>
<td>0x3d7(攻击合约)</td>
<td>0</td>
<td>0x0b123036</td>
<td>0x0..2b3c6f033f4a02b65</td>
<td></td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x3d7(攻击合约)</td>
<td>0x73a(AUR token)</td>
<td></td>
<td>{account:0x706(AurumNodePool)}</td>
<td>557774869144434074322370839</td>
<td>查询AurumNodePool中AUR余额</td>
</tr>
<tr>
<td>-changeRewardPerNode</td>
<td>0x3d7(攻击合约)</td>
<td>0x706(AurumNodePool)</td>
<td></td>
<td>{_rewardPerDay:434159898144856792986061626032}</td>
<td>0x</td>
<td>设置AurumNodePool合约中的_rewardPerDay值，这个是日奖励，居然可以任意设置，问题就出在这里</td>
</tr>
<tr>
<td>* claimNodeReward</td>
<td>0x3d7(攻击合约)</td>
<td>0x706(AurumNodePool）</td>
<td></td>
<td>{_creationTime:1669141375}</td>
<td>0x</td>
<td>获取奖励</td>
</tr>
<tr>
<td>-transfer</td>
<td>0x706(AurumNodePool）</td>
<td>0x3d7(攻击合约)</td>
<td></td>
<td>{recipient:0x3d7,amount:557774869144434074322370838}</td>
<td>True</td>
<td>转走奖励</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜一个公开_transfer攻击分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-23 10:08:00 / 修改时间：10:19:14" itemprop="dateCreated datePublished" datetime="2022-11-23T10:08:00+08:00">2022-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>这个攻击事件只是一个小事件，一次攻击获利不多，不过攻击者将这类型漏洞攻击自动化了，从攻击者的交易记录来看，还是有一些获利的。</p>
<p><strong>交易链接</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92">https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122200317537.png" alt="image-20221122200317537"></p>
<p><strong>攻击者地址</strong>：0xe3c5f54ab7a7a46810b24b272364c418b0151948</p>
<p><strong>攻击合约</strong>：</p>
<p>0x4c8986ed92f6cb908733206821d537927e4dfc29</p>
<p><strong>分析工具</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92">https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92/debugger?trace=0.11">https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92/debugger?trace=0.11</a></p>
<p><a target="_blank" rel="noopener" href="https://bscscan.com/tx/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92#eventlog">https://bscscan.com/tx/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92#eventlog</a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这次攻击利用了公开的_transfer漏洞，漏洞在WCH token合约内。</p>
<p><a target="_blank" rel="noopener" href="https://bscscan.com/address/0x011e02fd0da512841692279879d6ec49bf74ba7a#code#L632">https://bscscan.com/address/0x011e02fd0da512841692279879d6ec49bf74ba7a#code#L632</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">transferMultiWallet</span>(<span class="params">address sender,address recipient, uint256 amount</span>) external returns (bool) &#123;</span><br><span class="line">    <span class="title function_">_transfer</span>(sender, recipient, amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) internal &#123;</span><br><span class="line">    <span class="built_in">require</span>(sender != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;BEP20: transfer from the zero address&quot;</span>);</span><br><span class="line">    <span class="built_in">require</span>(recipient != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;BEP20: transfer to the zero address&quot;</span>);</span><br><span class="line"></span><br><span class="line">    _balances[sender] = _balances[sender].<span class="title function_">sub</span>(amount, <span class="string">&quot;BEP20: transfer amount exceeds balance&quot;</span>);</span><br><span class="line">    _balances[recipient] = _balances[recipient].<span class="title function_">add</span>(amount);</span><br><span class="line">    emit <span class="title class_">Transfer</span>(sender, recipient, amount);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用transferMultiWallet就可以将任意帐户的WCH发送到其他地址去，然后调用了sync强制同步PancakePair WCH-BUSD池中的储备量与余额，导致WCH价格飙升，然后再出售WCH将PancakePair WCH-BUSD池中的BUSD获取完。</p>
<h2 id="攻击步骤分析"><a href="#攻击步骤分析" class="headerlink" title="攻击步骤分析"></a>攻击步骤分析</h2><p>如下：</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122213929496.png" alt="image-20221122213929496"></p>
<p>通过分析工具：<a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92">https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122215419126.png" alt="image-20221122215419126"></p>
<p>下面是对具体步骤的详细拆分：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>From</th>
<th>To</th>
<th>Value</th>
<th>Input</th>
<th>Output</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>* CALL</td>
<td>0xe3c(攻击者)</td>
<td>0x4c8(攻击合约)</td>
<td>0.001BNB</td>
<td>0x9eb6f829……（raw data）</td>
<td>0x</td>
<td>猜测调用攻击合约某个方法，并发送0.01BNB用作燃料费</td>
</tr>
<tr>
<td>-staticall</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>0x8da5cb5b</td>
<td>0x15e（WCH token 持有人）</td>
<td>获取WCHtoken的创建者</td>
</tr>
<tr>
<td>-staticall</td>
<td>0x4c8(攻击合约)</td>
<td>0x10e(PancakeRouter)</td>
<td></td>
<td>0xc45a0155</td>
<td>0xca14（Pancake Factory）</td>
<td>获取Pancake Factory地址</td>
</tr>
<tr>
<td>-getPair</td>
<td>0x4c8(攻击合约)</td>
<td>0xca14（Pancake Factory）</td>
<td></td>
<td>{0x011(WCH token), 0xe9(BUSD token)}</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>获取WCH-BUSD交易池</td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{amunt:’0x257’}</td>
<td>435517532569589321744</td>
<td>获取0x257(PancakePair WCH-BUSD)中WCH的余额</td>
</tr>
<tr>
<td>* transferMultiWallet</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{sender:’0x257’，’recipient’:’0x15e’，amount:’435517532569589321734’}</td>
<td>True</td>
<td>通过任意transfer将0x257(PancakePair WCH-BUSD)中WCH的余额留下10个，其余全部转移到0x15e（WCH token 持有人）地址上，其实0x15也可以替换为其余可用地址，不是必定的</td>
</tr>
<tr>
<td>* PancakePair.sync</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td></td>
<td></td>
<td></td>
<td>True</td>
<td>调用0x257(PancakePair WCH-BUSD)合约的sync方法进行同步，让合约储备量和余额（10）保持一致。此时WCH只剩下10，BUSD数量不变，为保证K值，导致WCH价格飙升</td>
</tr>
<tr>
<td>* CALL</td>
<td>0x4c8(攻击合约)</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td></td>
<td>0xff6cae9</td>
<td>0x</td>
<td>调用0x257(PancakePair WCH-BUSD)执行某个方法，目的是确认0x257(PancakePair WCH-BUSD)中WCH和BUSD余额</td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{amount: 0x257(PancakePair WCH-BUSD)}</td>
<td>10</td>
<td>查询0x257(PancakePair WCH-BUSD)中WCH余额，为10</td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>0xe9(BUSD token)</td>
<td></td>
<td>{amunt: 0x257(PancakePair WCH-BUSD)}</td>
<td>456365713891375952252</td>
<td>查询0x257(PancakePair WCH-BUSD)中BUSD余额，为456365713891375952252</td>
</tr>
<tr>
<td>* balanceOf</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{account: 0x15e(WCH持有者)}</td>
<td>435517532569589321734</td>
<td>查询WCH持有者中WCH余额，为435517532569589321734</td>
</tr>
<tr>
<td>* transferMultiWallet</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{sender:’0x15e’,’recipient’:’0x15e’’0x257’,amount:’435517532569589321734’}</td>
<td>True</td>
<td>通过任意transfer，将0x15e(WCH持有者)中所有的WCH都发送给0x257(PancakePair WCH-BUSD)，这意味着现在有用户即将进行WCH-BUSD的兑换（swap），接下来就可以调用0x257(PancakePair WCH-BUSD)的swap方法将换取的BUSD兑换到任何地址了。需要注意，当前transfer和接下来的swap一定要在同一笔交易内完成，不可分割，不然其他人也可以通过swap方法转走这一笔BUSD。还值得注意的一点是，池子中的BUSD其实只需要10WCH就可以兑换完的。</td>
</tr>
<tr>
<td>* getAmountOut</td>
<td>0x4c8(攻击合约)</td>
<td>0x10e(PancakeRouter)</td>
<td></td>
<td>{amountIn:435517532569589321734,reserverIn:10,reserverOut:456365713891375952252 }</td>
<td>amountOut:456365713891375952241</td>
<td>查询435517532569589321734WCH可以兑换多少BUSD，可换456365713891375952241</td>
</tr>
<tr>
<td>* PancakePair.swap</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>0x4c8(攻击合约)</td>
<td></td>
<td>{amount0Out:0,amount1Out:456365713891375952241,to:0x4c8(攻击合约)}</td>
<td>true</td>
<td>将BUSD兑换到0x4c8(攻击合约)。这里需要了解swap的特性，只要之前有人tranferWCH到Pair内，任何人都可以通过swap转走这笔钱，所以要保证transfer和swap一起</td>
</tr>
</tbody></table>
<p>剩下的步骤就是把获得的BUSD换成BNB，就不做详述了。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122215622414.png" alt="image-20221122215622414"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此类问题的原因还是权限控制没有做好，将原本internal的方法公开了，导致任何人都可以调用原本的内部函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/02/Uniswap%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BD%9CUniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/02/Uniswap%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BD%9CUniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Uniswap系列(二)｜Uniswap的交易与流动性原理详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-02 14:42:29 / 修改时间：15:43:37" itemprop="dateCreated datePublished" datetime="2022-11-02T14:42:29+08:00">2022-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-交易所"><a href="#1-交易所" class="headerlink" title="1.交易所"></a>1.交易所</h2><p>​	传统的中心化交易所，以股票、公司债券等为交易对象的叫证券交易所，以大宗商品(如棉花、小麦等)为交易对象的叫商品交易所。而在Uniswap中，交易对象是虚拟货币。</p>
<p>​	先来说一下中心化交易所是怎么进行交易的：在中心化交易所有一个东西叫做订单簿（order book），它保存了所有的买单、卖单信息。并将合适的买单、卖单撮合成一笔交易。如下表所示就是一个订单薄，一般会同时展示买卖双方的订单情况。</p>
<table>
<thead>
<tr>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>20000</td>
</tr>
<tr>
<td>99.2</td>
<td>10000</td>
</tr>
<tr>
<td>99.1</td>
<td>10000</td>
</tr>
<tr>
<td>86.2</td>
<td>500</td>
</tr>
<tr>
<td>80.1</td>
<td>1</td>
</tr>
</tbody></table>
<p>​	<img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221101175859542.png" alt="image-20221101175859542"></p>
<p>​	如果该交易所足够繁荣，那么只要价格合理，买卖双方的交易会很快匹配到合适的订单。相反，如果平台上的买卖双方不够活跃，这个时候用户发出的买单或买单可能很长时间才会有找到合适的交易方进行交易，就会出现长时间挂单的情况，导致效率低下。为了解决这种问题，就出现了做市商。</p>
<h2 id="2-做市商"><a href="#2-做市商" class="headerlink" title="2.做市商"></a>2.做市商</h2><p>​	做市商是指在传统证券市场上，由具备一定实力（资金足够支持用户大金额交易，因为它要同时承担买方和卖方的角色）和信誉（不能出现机构随意操控市场的情况）的独立证券经营法人作为特许交易商。</p>
<p>​	做市商不断向公众投资者报出某些特定证券的买卖价格，并在该价位上接受公众投资者的买卖要求，以其自有资金和证券与投资者进行证券交易。买卖双方不需等待交易对手出现，只要有做市商出面承担交易对手方既可达成交易。</p>
<p>​	做市商通过做市制度来维持市场的流动性，满足公众投资者的投资需求。做市商通过买卖报价的适当差额来补偿所提供服务的成本费用，并实现一定的利润。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102104721074.png" alt="image-20221102104721074"></p>
<p>​		有了做市商后，卖方挂的单会由做市商给买下来，买家买的单会由做市商卖给买家。也就是说买卖双方不再是直接交易了，实际上买卖双方都在和做市商进行交易。有些人会觉得做市商和庄家一样，其实不是的，做市商是有情怀，他们要去维护市场的稳定繁荣。而庄家可不给你讲什么情怀，他们唯恐天下不乱，就希望市场混乱，好进行高买低卖，以此牟利。做市商给出的买卖价格是双向报价，它会有一个对市场的大概评估，当过于低迷或者是过于火热的时候，超出估值范围，做市商会控制估值维护市场稳定。</p>
<h2 id="3-自动化做市商"><a href="#3-自动化做市商" class="headerlink" title="3.自动化做市商"></a>3.自动化做市商</h2><p>​	而在区块链的世界中，如果要复刻中心化交易所的模式，是有缺陷的。第一点：无法确定做市商有足够的资本。第二点：区块链没有监管机构，无法完全避免做市商监守自盗的可能性。</p>
<p>​	所以Uniswap提出了一种通过智能合约实现自动化做市商（Automated Market Maker，AMM）来与用户进行交易的去中心化交易协议，用户资产完全由自己控制，而智能合约中锁定的做市资产也可公开查看，是一种更安全透明的交易方式。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102105320892.png" alt="image-20221102105320892"></p>
<p>​	从上图可以看到，现在买卖方都只和区块链中的自动做市商智能合约程序进行交互了，自动做市商要实现能够自动和买&#x2F;卖方完成交易，需要满足几个特性：</p>
<ul>
<li>要持有资产，由于要做双向报价，那就是一种代币换取另一种代币，所以要持有两种资产。</li>
<li>资金池要能够充值、提现。</li>
<li>要能根据市场情况自动调整价格。</li>
<li>要能够通过交易赚取利润。</li>
</ul>
<h2 id="4-自动化做市商的实现"><a href="#4-自动化做市商的实现" class="headerlink" title="4.自动化做市商的实现"></a>4.自动化做市商的实现</h2><h3 id="4-1-流动性介绍"><a href="#4-1-流动性介绍" class="headerlink" title="4.1 流动性介绍"></a>4.1 流动性介绍</h3><p>​	Uniswap中有一个重要的概念就是流动资金池，它由两个ERC-20代币（token）储备组成，它就是这一对ERC-20代币的交易场所。</p>
<p>​	在最初，资金池中每个token的余额为0，为了让资金池能够进行交易，需要有一个人存入两种代币作为初始存款，同时存入两种代币的行为叫做提供流动性，这个提供流动性的人人被称为流动性提供者，并且获得流动性池份额（LPS）。而这第一个流动性提供者也是设定资金池初始价格的人。</p>
<p>​	举个栗子🌰：此时要创建一个A、Btoken的池子。流动性提供者小明提供了10000枚A token，1000枚B token的流动性进入流动池。</p>
<p>​	流动池中A、B的价格是通过池子中两种代币的数量比来决定的。直观的理解就是两种代币的总价值是相同的，每次交易完之后由于两种代币的数量会发生变化，相对价格也会变化，价格的调整遵循如下公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x * y = k  (k为常数)</span><br></pre></td></tr></table></figure>

<p>​	x、y代表两种token的数量，此时：k&#x3D;100,000*1000&#x3D;100,000,000。</p>
<p>​	提供流动性后会获得流动性份额LPS，计算的公式是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sqrt</span>(x * y)</span><br></pre></td></tr></table></figure>

<p>​	此时：LPS&#x3D; sqrt(100,000*1000)&#x3D;10000。使用几何平均数计算的好处是可以使LPS在任何时候都不受质押的两种代币的比例影响，因为两种代币在流动性池中的比例可能与市场价格不符。</p>
<p>​	如下图所示，现在质押了10000个A代币，1000个B代币，产生了10000个LPS。现在A:B&#x3D;100:1，也就是说现在100个A代币可以兑换1个B代币。而流动性提供者小明获持有100%的LPS，共10000LPS。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102122324589.png" alt="image-20221102122324589"></p>
<p>​		需要注意的是，在实际情况下，第一次提供流动性时，返回的LPS其实是有调整的，任何流动性池在启用之初都要在零地址中锁定<code>1e-15</code>的LPS。原因是智能合约中LPS的位数是18位，理论上有一种情况，就是初始情况的LPS&#x3D;1，就是最小量即<code>1e-18</code> LPS。如果此时1LPS&#x3D;1000$的话，后续流动性提供者必须要质押价值大于1000$的流动性才可以获得1个LPS，导致添加流动性的成本变高，这是不利于维持交易的流动性的。在Uniswap白皮书中把这种极端情况认为是一种可能的人为攻击，为了提高这种攻击的成本，在新创建流动性池的时候，设置了一个最小流动性值<code>MINIMUM_LIQUIDITY=1e-15=1000</code>，即LPS最小单位的1000倍，任何流动性池在启用之初都要在零地址中锁定<code>1e-15</code>的LPS。所以修订后的图为：</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102125528344.png" alt="image-20221102125528344"></p>
<p>​	在这种机制之下，如果人为把LPS价值提升到1e-18 &#x3D; $100的话，就需要在零地址中锁定价值 $100 * 1e3 &#x3D; $100000 的LPS，这样就极大地提升了攻击成本，而且在通常情况下，1e-15的LPS的价值是很小的，甚至可以忽略，所以修订图中第一次质押后获得的LPS虽然要减少1e-15LPS，但约等于10000不变。当然也会有极端情况，例如Pair中质押的两种代币都没有小数，而且单价很高，那么1e-15LPS的价值还是可以感知到的，不过这种类型的代币也不太适合用Uniswap协议来交易。</p>
<h3 id="4-2-添加-x2F-销毁流动性"><a href="#4-2-添加-x2F-销毁流动性" class="headerlink" title="4.2 添加&#x2F;销毁流动性"></a>4.2 添加&#x2F;销毁流动性</h3><p>​	后续，如果要继续提供流动性，则按新增的流动性等比例增发LPS，假设当前Pool中X的量为x_current，Y的量为y_current，存量LPS为s_current，新增加的流动性中的X为x_add，Y为y_add（通常情况下x_current&#x2F;y_current &#x3D; x_add&#x2F;y_add，即等比例增加流动性），则新增发的LPS为s_add:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_add = <span class="title function_">min</span>(x_add/x_current, y_add/y_current) * s_current</span><br></pre></td></tr></table></figure>

<p>​	比如增加2000个A token，20个B token，那么按照公式计算，会增发200LPS。如果说我要增加2000个A token，30个B token，那么会取min(2000&#x2F;100000，30&#x2F;1000)*10000&#x3D;50&#x3D;200，还是会增发200LPS，另一种多出来B的不会去质押，会返还避免损失。当然，如果直接操作Pair合约没有自己进行校验，可能导致多余的的B不会返还。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102132232247.png" alt="image-20221102132232247"></p>
<p>​	如果要销毁流动性，就会等比例的返还A、B两种token，计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_withdraw = s_remove/s_current * x_current</span><br><span class="line">y_withdraw = s_remove/s_current * y_current</span><br></pre></td></tr></table></figure>

<p>比如现在销毁100LPS，那么就会取的A 共计（100&#x2F;10200）* 102000 &#x3D; 1000，B共计：（100&#x2F;10200）* 1020 &#x3D; 10。此时LPS &#x3D; 10200-100&#x3D;10100。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102133727220.png" alt="image-20221102133727220"></p>
<h3 id="4-3-交易"><a href="#4-3-交易" class="headerlink" title="4.3 交易"></a>4.3 交易</h3><p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102142719452.png" alt="image-20221102142719452"></p>
<p>​	如上图所示，该流动性池子最开始有100X和1Y，所以初始价格是100个Xtoken，可以兑换1个Ytoken。而价格曲线遵循<code>x*y=k</code>，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x+x_swap) * (y-y_swap) = k</span><br><span class="line">y_swap = y- k/(x+x_swap) = (x_swap*y)/x+x_swap</span><br></pre></td></tr></table></figure>

<p>​	而X、Ytoken的价格也会随着两者数量的变化而发生改变，最终形成一条价格曲线<code>x*y=k</code>。</p>
<p>​	如上图所示，原流动性池中两种代币余额为100 X和1 Y，可认为Y相对X的价格为1 Y &#x3D; 100 X，此时要通过流动性池交易20个X，如果按照当前价格全量交易的话，应该换回 20 &#x2F; 100 &#x3D; 0.2 个Y，而在Uniswap中，每当发生交易时，都会向交易发送者收取 0.3% 的费用。这笔费用在交易完成后按比例分配给池中的所有 LP。所以再减去0.3%的手续费，最后返回0.1994个Y，但实际返回了0.1658个Y，我们来逐步分析一下：</p>
<ol>
<li><p>输入20个X，先扣除0.3%的手续费，即实际交易量为19.94个X。</p>
</li>
<li><p>按照x*y&#x3D;k（k&#x3D;1*100&#x3D;100）的公式进行计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(100+19.94) * (1-y_swap) = 100。</span><br><span class="line">y约为0.1658.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Uniswap pair会给交易者地址返回0.1658个Y，此交易平均交易价格为 1 Y &#x3D; 20 &#x2F; 0.1658 X &#x3D; 120.6273 X，比交易开始时的100要高20%多，主要是因为交易量20个X相对于流动性池的比例较大（20%），相当于大额交易，对价格会产生较大影响，直观的感觉就是市场上有人大量买入Y，从而导致Y的价格上涨，此笔交易之后，交易池中Y相对于X的价格变为了143.8504。</p>
</li>
<li><p>更新流动性池中的余额，虽然交易的时候扣掉了0.3%的手续费，但实际上这个手续费依然会放到流动性池中，作为流动性提供者的收益，因此X更新后的余额还是100 + 20 &#x3D; 120，Y的余额是1 - 0.1658 &#x3D; 0.8342，Liquidity Shares的值不变。随着交易手续费的积累，整个流动性池的总价值在上涨，LPS的总量不变，则LPS的单位价值上涨。</p>
</li>
</ol>
<p>​	由于有手续费的原因，X、Ytoken的数量都在慢慢增多，所以k值其实也不是一直守恒着的，K值其实是在慢慢变大的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380749685">Uniswap深度科普</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.uniswap.org/protocol/V2/introduction">Uniswap v2 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/272241656">合约安全(4):为啥说UniswapK值不那么守恒</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ELLEN"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ELLEN</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ELLEN</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
