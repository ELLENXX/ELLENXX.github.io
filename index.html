<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ELLEN&#39;s BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ELLEN&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ELLEN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ELLEN's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ELLEN's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/13/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/13/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜BEVO 代币deliver攻击事件分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-13 16:22:10 / 修改时间：16:28:13" itemprop="dateCreated datePublished" datetime="2023-02-13T16:22:10+08:00">2023-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h1><p>北京时间2023年1月31日，在twitter上看到这样一条消息：</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213141240813.png" alt="image-20230213141240813"></p>
<p>BEVO 代币被攻击，总共损失45000美元，导致BEVO 代币的价格下跌了 99%。</p>
<p>有趣的是，这个事件中还出现了抢跑，上演了一幕黑吃黑。</p>
<p>twitter：<a target="_blank" rel="noopener" href="https://twitter.com/peckshield/status/1619996999054667784">https://twitter.com/peckshield/status/1619996999054667784</a></p>
<p>成功交易链接：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d">https://bscscan.com/tx/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d</a></p>
<p>被抢跑交易：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0x581c7674a6adfaa4351422781f6b674e2b7ac0fab0db9d46bfcb559ddd96cff8">https://bscscan.com/tx/0x581c7674a6adfaa4351422781f6b674e2b7ac0fab0db9d46bfcb559ddd96cff8</a></p>
<p>分析工具：</p>
<p><a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d">https://phalcon.blocksec.com/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d">https://dashboard.tenderly.co/tx/bsc/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d</a></p>
<h1 id="二、事件分析"><a href="#二、事件分析" class="headerlink" title="二、事件分析"></a>二、事件分析</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>被攻击的原因在于<code>deliver</code>方法，当调用该合约的<code>deliver</code>方法时，会减少代币的总价值，导致计算余额出现了误差，造成储备量与余额的不平衡，攻击者通过<code>skim</code>获利。</p>
<h2 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h2><p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213143457009.png" alt="image-20230213143457009"></p>
<ol>
<li><p>攻击者通过闪电贷获得了192.5 WBNB，并通过Pancake交换出来3,028,774,323,006,137,313 BEVO代币。</p>
</li>
<li><p>调用<code>deliver</code>方法，减少总额<code>_rTotal</code>数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function deliver(uint256 tAmount) public &#123;</span><br><span class="line">        address sender = _msgSender();</span><br><span class="line">        require(!_isExcluded[sender], &quot;Excluded addresses cannot call this function&quot;);</span><br><span class="line">        (uint256 rAmount,,,,,,) = _getValues(tAmount);</span><br><span class="line">        _rOwned[sender] = _rOwned[sender].sub(rAmount);</span><br><span class="line">        _rTotal = _rTotal.sub(rAmount);</span><br><span class="line">        _tFeeTotal = _tFeeTotal.add(tAmount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.调用<code>skim</code>方法，在<code>skim</code>中要查询池子中BEVO的余额，过程中会根据<code>_getRate()</code>方法计算BEVO的价值比率，然后计算出当前余额。</p>
<p>先看<code>_getRate()</code>,计算公式是<code>rSupply.div(tSupply)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function _getRate() private view returns(uint256) &#123;</span><br><span class="line">        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();</span><br><span class="line">        return rSupply.div(tSupply);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213150214342.png" alt="image-20230213150214342"></p>
<p>而从<code>_getCurrentSupply()</code>方法中得出的<code>rSupply</code>就和<code>_rTotal</code>有关，由于<code>deliver</code>导致<code>_rTotal</code>减少，所以<code>rSupply.div(tSupply)</code>的比值<code>currentRate</code>也随之减小。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213151242277.png" alt="image-20230213151242277"></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213151328359.png" alt="image-20230213151328359"></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CBEVO%20%E4%BB%A3%E5%B8%81deliver%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20230213151311939.png" alt="image-20230213151311939"></p>
<p>最终的余额是<code>rAmount.div(currentRate)</code>计算出来的，<code>rAmount</code>在执行过程中没有被改变过，所以分子不变分母减小，自然导致了余额变大了。</p>
<p>计算出来余额：<code>6844218532359160336</code>,储备量：<code>2298813336114922094</code>,多出的<code>4545405196244238242</code>就被发给了攻击者。</p>
<p>4.攻击者又调用了一次<code>deliver</code>，将<code>_rototal</code>再减少<code>4545405196244238242</code>，使余额与储备量不一致。然后调用了<code>swap</code>方法获利了337个BNB。除去闪电贷192.5个BNB，攻击者最终获得144.5个BNB，总计45000美元。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这起事件后风波没有停止，后来还出现了其他类似的攻击手法，有的攻击者在bsc链上批量扫描符合要求的代币并实施攻击。</p>
<p>从这次攻击事件来看，金额计算模型设计需要谨慎，避免出现参数可控导致的问题，这是保证项目安全及其重要的部分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/20/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/20/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">默克尔树（Merkle Patricia Tree）详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-20 17:04:48" itemprop="dateCreated datePublished" datetime="2023-01-20T17:04:48+08:00">2023-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-22 17:08:59" itemprop="dateModified" datetime="2023-01-22T17:08:59+08:00">2023-01-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>本文是阅读《深入以太坊智能合约开发》的附录A Merkle Patricia Tree后的知识归纳以及扩展。</p>
<blockquote>
<p>默克尔树（Merkle Patricia Tree）在以太坊中是一种通用的，用来存储键值对的数据结构，可以简称为“MPT”，是字典树Redix tree的变种，也是以太坊的核心算法之一。</p>
<p>MPT对于树中节点的插入、查找、删除操作，这种结构可以提供对数级别的复杂度O(log(N))，所以它是一种相对高效的存储结构。</p>
</blockquote>
<h1 id="二、如何根据键值对构造默克尔树"><a href="#二、如何根据键值对构造默克尔树" class="headerlink" title="二、如何根据键值对构造默克尔树"></a>二、如何根据键值对构造默克尔树</h1><h2 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h2><p>树类型的数据结构，都会有节点的概念，MPT也不例外。</p>
<p>MPT中有三种节点类型：branch、leaf、extension：</p>
<ol>
<li><p><strong>branch（分支）</strong></p>
<ul>
<li>由17个元素组成的元组，格式为：(v0,……,v15,vt)。</li>
<li>其中，v0～v15的元素是以其索引值（0x0~0xf）为路径的子节点数据的keccak256哈希值，如果没有子节点数据则元素为空。</li>
<li>vt为根节点到当前节点的父节点所经过的路径对应的value值，也就是根节点到父节点所经过的路径组成了一个键key，这个key对应的value存在vt里面，如果这个key没有对应的value，那么vt为空。</li>
</ul>
</li>
<li><p><strong>leaf（叶）</strong></p>
<ul>
<li>两个元素组成的元组，格式为：（encodePath,value）</li>
<li>encodedPath为当前节点路径的十六进制前缀编码</li>
<li>value是从根节点到当前节点路径组成的键对应的值</li>
</ul>
</li>
<li><p><strong>extension（扩展）</strong></p>
<ul>
<li>两个元素组成的元组，格式为：（encodePath,key）</li>
<li>encodedPath为当前节点路径的十六进制前缀编码</li>
<li>key为当前节点子节点数据的keccak256哈希值</li>
</ul>
</li>
</ol>
<p>总结一下上述的那一堆概念：</p>
<ul>
<li><p>键值对</p>
</li>
<li><p>extension节点记录着：路径、子节点的哈希值。</p>
</li>
<li><p>leaf节点记录着：路径、vlaue。</p>
</li>
<li><p>branch记录着：以索引值为路径的子节点的哈希值、从根节点到branch的父节点路径组成的键对应的value。</p>
</li>
<li><p>value值在leaf和branch节点中存放，key被拆解开，最终由extension、leaf的encodePath以及branch的索引值组成。</p>
</li>
</ul>
<h2 id="2-2-十六进制前缀编码"><a href="#2-2-十六进制前缀编码" class="headerlink" title="2.2 十六进制前缀编码"></a>2.2 十六进制前缀编码</h2><p>branch和extension元组的第一个元素encodePath就是当前节点路径的十六进制前缀编码（Hex-Pretix Encoding，HP编码）。使用HP编码能够区分节点是扩展结点还是叶子节点。<br>而HP编码，和当前节点类型还有当前路径半字节长度的奇偶有关。</p>
<blockquote>
<p>半字节是4位二进制，即1位16进制。</p>
<p>0xf是半字节，0xff是1字节。</p>
<p>1111是半字节，11111111是1字节。</p>
</blockquote>
<p>共有四种前缀：</p>
<table>
<thead>
<tr>
<th>路径所对应的节点类型</th>
<th>路径长度</th>
<th>二进制数值</th>
<th>十六进制数值</th>
<th>最终前缀（HP前缀）</th>
</tr>
</thead>
<tbody><tr>
<td>Extension</td>
<td>偶数个半字节</td>
<td>0000</td>
<td>0x0</td>
<td>0x00</td>
</tr>
<tr>
<td>Extension</td>
<td>奇数个半字节</td>
<td>0001</td>
<td>0x1</td>
<td>0x1</td>
</tr>
<tr>
<td>leaf</td>
<td>偶数个半字节</td>
<td>0010</td>
<td>0x2</td>
<td>0x20</td>
</tr>
<tr>
<td>leaf</td>
<td>奇数个半字节</td>
<td>0011</td>
<td>0x3</td>
<td>0x2</td>
</tr>
</tbody></table>
<p>所以extension节点有两种前缀：0x00、0x1；leaf有两种前缀：0x20、0x3。</p>
<p>可以看到最终前缀在偶数个半字节0x0、0x2后补了一个0，变成了0x00，0x20，目的是为了凑成整字节，避免出现半字节导致长度不便于合并。</p>
<p>HP前缀需要放在原始路径前面去组成HP编码，实例：</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>节点类型</th>
<th>HP前缀</th>
<th>HP编码</th>
</tr>
</thead>
<tbody><tr>
<td>(0x012345,key)（注：012345长度为偶数）</td>
<td>Extension</td>
<td>0x00 (0000 0000)</td>
<td>(<strong>0x00</strong>012345,key)</td>
</tr>
<tr>
<td>(0x12345,key)（注：12345长度为奇数）</td>
<td>Extension</td>
<td>0x1 (0001)</td>
<td>(<strong>0x1</strong>2345,key)</td>
</tr>
<tr>
<td>(0x0f1cb8,value)（注：0f1cb8长度为偶数）</td>
<td>leaf</td>
<td>0x20 (0010 0000)</td>
<td>(<strong>0x20</strong>0f1cb8,value)</td>
</tr>
<tr>
<td>(0xf1cb8,value)（注：f1cb8长度为奇数）</td>
<td>leaf</td>
<td>0x3 (0011)</td>
<td>(<strong>0x3</strong>f1cb8,value)</td>
</tr>
</tbody></table>
<h2 id="2-3-构造一颗默克尔树"><a href="#2-3-构造一颗默克尔树" class="headerlink" title="2.3 构造一颗默克尔树"></a>2.3 构造一颗默克尔树</h2><p>上面的概念不容易理解，现在我们以下面的例子，一步步来进行树的构造，帮助我们更好的理解：</p>
<blockquote>
<p>我们假设有一组（4个）键值对数据需要用树来存储：</p>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; : ‘puppy’</p>
<p>&lt;64 6f 67 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
<p>为方便解释说明以及阅读，我们把键值对数据的“键”表示为十六进制字符串，“值”则保留为原始字符串。在实际使用时，它们都需要经过特定的编码变换。</p>
</blockquote>
<h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><blockquote>
<p>&lt;**6**4 6f&gt; : ‘verb’</p>
<p>&lt;**6**4 6f 67&gt; : ‘puppy’</p>
<p>&lt;**6**4 6f 67 65&gt; : ‘coin’</p>
<p>&lt;**6**8 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>每棵树都有根节点，默克尔树的根节点会保存当前路径和子节点哈希，所以很明显，根节点会是一个extension节点。</p>
<p>上面节点类型介绍了extension格式为：（encodePath,key），encodePath是十六进制的HP编码。分析给出的4个键我们可以得出都是以6开头，后面分为4、8两条路。所以根节点存储的共同路径值为0x6。</p>
<p>由于0x6只有一位，所以路径长度是奇数，节点又是extension类型，所以HP前缀是0x1，组合出来的HP编码：<strong>0x1</strong>6。</p>
<p>所以当前默克尔树如下图：</p>
<img src="../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120151314398.png" alt="image-20230120151314398" style="zoom:50%;" />

<p>HashA代表着子节点的哈希值。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><blockquote>
<p>&lt;6**4** 6f&gt; : ‘verb’</p>
<p>&lt;6**4** 6f 67&gt; : ‘puppy’</p>
<p>&lt;6**4** 6f 67 65&gt; : ‘coin’</p>
<p>&lt;6**8** 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>根节点已经找到，但在根节点后出现了两条路，这个时候需要使用branch来处理这种多条路径的情况。</p>
<p>上文说到，branch由17个元素组成的元组，格式为：(v0,……,v15,vt)。其中，v0～v15是以其索引值（0x0~0xf）为路径的子节点数据的keccak256哈希值，如果没有子节点数据则为空。</p>
<p>这里4和8就是索引值，4、8对应元素是其字节点的哈希值。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120152905919.png" alt="image-20230120152905919"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; : ‘puppy’</p>
<p>&lt;64 6f 67 65&gt; : ‘coin’</p>
<p>&lt;68 <strong>6f 72 73 65&gt; : ‘stallion’</strong></p>
</blockquote>
<p>我们可以观察到，在0x68后只有唯一路径了，即0x6f727356，而value为“stallion”，所以不再分叉的情况下，就不是branch或者extension了，而应该是一个leaf叶节点。</p>
<p>上文提到，leaf节点是两个元素组成的元组，格式为：（encodePath,value），encodedPath为当前节点路径的十六进制前缀编码，value是从根节点到当前节点路径组成的键，所对应的值。</p>
<p>当前节点的路径是0x6f727356，长度是偶数，节点类型是leaf，所以可以得出HP前缀是0x20，HP编码是<strong>0x20</strong>6f727356。所以可得该leaf节点：（0x206f727356,”stallion”）。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120154202691.png" alt="image-20230120154202691"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><blockquote>
<p>&lt;64 **6f**&gt; : ‘verb’</p>
<p>&lt;64 **6f** 67&gt; : ‘puppy’</p>
<p>&lt;64 **6f** 67 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>说完了8，我们再说说4这部分，路径4后面有共同路径6f，6f后才产生null和6两条分叉。</p>
<p>共同路径6f是一个extension节点，extension节点格式不再介绍，开始计算HP编码，6f长度是偶数，又是extension类型，所以HP前缀为0x00，HP编码为<strong>0x00</strong>6f。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120155033149.png" alt="image-20230120155033149"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><blockquote>
<p>&lt;64 6f&gt; <strong>: ‘verb’</strong></p>
<p>&lt;64 6f **6**7&gt; : ‘puppy’</p>
<p>&lt;64 6f **6**7 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>6f后分出了null和6，是多条路径，所以HashD的节点是一个branch节点，6是索引值，索引为6的元素存储着子节点hash；而null是没有的，上文提到：vt为根节点到当前节点的父节点所经过的路径组成的键对应的value。</p>
<p>则代表当前HashD节点该存储从根节点到父节点0x646f组成的键对应的值：’verb’。那么该由HashD的vt保存’verb’。</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120160053382.png" alt="image-20230120160053382"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 6**7**&gt; : ‘puppy’</p>
<p>&lt;64 6f 6**7** 65&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>接下来是共同路径7，一个extension节点，开始计算HP编码，7长度是奇数，又是extension类型，所以HP前缀为0x1，HP编码为<strong>0x1</strong>7。</p>
<p>所以当前默克尔树如下图：</p>
<img src="../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120160420895.png" alt="image-20230120160420895" style="zoom:50%;" />

<h4 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; <strong>: ‘puppy’</strong></p>
<p>&lt;64 6f 67 **6**5&gt; : ‘coin’</p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>7后分出了null和6，是多条路径，与第五步相同，HashF是一个branch节点，索引为6的元素存储子节点哈希，vt存储’puppy’的值</p>
<p>所以当前默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120160833192.png" alt="image-20230120160833192"></p>
<h4 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h4><blockquote>
<p>&lt;64 6f&gt; : ‘verb’</p>
<p>&lt;64 6f 67&gt; : ‘puppy’</p>
<p>&lt;64 6f 67 6<strong>5&gt; : ‘coin’</strong></p>
<p>&lt;68 6f 72 73 65&gt; : ‘stallion’</p>
</blockquote>
<p>好了，现在只剩下一条路径了，表示这最后一个是一个leaf叶子节点，路径为5，路径长度为奇数，索引HP前缀为0x3，HP编码为<strong>0x3</strong>5</p>
<p>所以当前也是最终的默克尔树如下图：</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120161243321.png" alt="image-20230120161243321"></p>
<p>以上就是这棵默克尔树构造的全部过程了，写得很详细，是希望能够为在阅读书籍时没有理顺思路的小伙伴们提供一些帮助。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>从构造过程中我们可以看出，MPT中节点之间，是通过哈希值来确定的。由于哈希值的特性，只要数据有了微小改动，就会导致根节点改变，所以我们可以用树的根节点来代表整个树中数据的状态，这样就不用保存整个树的数据。</p>
<p>在以太坊中，默克尔树有着大量的应用，比如保存和验证系统中的所有账户状态、所有合约的存储状态、区块中的所有交易和所有收据数据的状态等。</p>
<p><img src="/../images/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91%EF%BC%88Merkle%20Patricia%20Tree%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20230120163214097.png" alt="image-20230120163214097"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/2020/01/27/7c1fcd777d7b">【深度知识】以太坊区块数据结构及以太坊的4棵数</a></p>
<p>《深入以太坊智能合约开发》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/07/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/07/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜RFB一起多次买卖获利分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-07 16:30:00 / 修改时间：16:32:53" itemprop="dateCreated datePublished" datetime="2022-12-07T16:30:00+08:00">2022-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li></li>
</ul>
<h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><p>攻击者：0x5f7db41e2196080f397cdcf8dd58e8adfdaf2ade</p>
<p>攻击合约：0xd5de2914bc6d2f005228a04289e8d518c710a049</p>
<p>交易信息：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a">https://bscscan.com/tx/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a</a></p>
<p>分析工具：</p>
<p><a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a">https://phalcon.blocksec.com/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a/debugger">https://dashboard.tenderly.co/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a/debugger</a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>攻击者获利1.17个BNB。原因是RFB在买入时有一个奖励机制存在漏洞。而攻击者就不断的通过大约20BNB去买入卖出RFB，来触发这个奖励机制。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/image-20221207160733104.png" alt="image-20221207160733104"></p>
<p>我们看奖励机制的核心代码：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L264">https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L264</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/image-20221207160459448.png" alt="image-20221207160459448"></p>
<p>买入RFB时，会用到<code>_transferFrom</code>，执行到最后，如果使用的是WBNB与RFB兑换的pair，就会触发奖励机制<code>randMod</code>。</p>
<p><a target="_blank" rel="noopener" href="https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L417">https://bscscan.com/address/0x26f1457f067bf26881f311833391b52ca871a4b5#code#L417</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CRFB%E4%B8%80%E8%B5%B7%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%88%A9%E5%88%86%E6%9E%90/image-20221207160904379.png" alt="image-20221207160904379"></p>
<p>这里应该是随机出的数能刚好满足<code>randnum%(10*luckyMultiplier) == 8</code>的条件，然后执行了<code>distributor.withdrawPlazz(buyer, buyBNBamount.mul(90).div(100))</code>，<code>distributor</code>在合约创建是已经确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributor = IDividendDistributor(0x2BD049f1a6A4e93421D93d72AfB7Cb22Cd958c43);</span><br></pre></td></tr></table></figure>

<p>这里的<code>buyer</code>就是<code>0xd5de2914bc6d2f005228a04289e8d518c710a049</code>的地址。</p>
<p>攻击步骤很简单：</p>
<ul>
<li>攻击者通过闪电贷贷出20BNB</li>
<li>不断的买卖RFB，而且没有真正交易成功，最后回滚了交易，但是却能成功的触发奖励。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/30/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/30/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜DPC攻击事件分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-30 13:17:27 / 修改时间：14:16:43" itemprop="dateCreated datePublished" datetime="2022-11-30T13:17:27+08:00">2022-11-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>北京时间2022年9月10日，DPC代币合约遭到黑客攻击，损失超73,614BUSD。</p>
<p>DPC合约是一个ERC20代币合约，除了基本的ERC20代币功能，用户还可以将DPC代币与BUSD进行质押来获得DPC代币奖励。</p>
<p>攻击记录：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x2109bbecB0a563e204985524Dd3DB2F6254AB419">https://bscscan.com/address/0x2109bbecB0a563e204985524Dd3DB2F6254AB419</a></p>
<p>攻击者地址：0xf211fa86cbc60d693d687075b03dff3c225b25c9</p>
<p>攻击合约：0x2109bbecb0a563e204985524dd3db2f6254ab419</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>DPC合约中计算奖励算法存在漏洞，攻击者通过调用<code>claimStakeLp</code>函数取出之前质押的LP，在<code>claimStakeLp</code>中一是没有对每次取出的LP进行数量限制，二是在每次取出LP时计算奖励操作进行了两次，导致计算奖励时会翻倍增加，从而使攻击者有利可图。</p>
<h2 id="攻击步骤如下"><a href="#攻击步骤如下" class="headerlink" title="攻击步骤如下"></a>攻击步骤如下</h2><p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130131625508.png" alt="image-20221130131625508"></p>
<ol>
<li><p>向DPC转移42次BUSD，每次100枚，共计4200BUSD。此步骤调用了dpc合约中的tokenAirdrop方法：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0xb75ca3c3e99747d0e2f6e75a9fbd17f5ac03cebe#code#L1076">https://bscscan.com/address/0xb75ca3c3e99747d0e2f6e75a9fbd17f5ac03cebe#code#L1076</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130122920065.png" alt="image-20221130122920065"></p>
</li>
<li><p>用50枚BUSD兑换DPC，扣除手续费共兑换了约3.63枚。用兑换得到的DPC与约47.4个BUSD进行流动性添加，获得约12.29LP，并将这些流动性进行质押。</p>
</li>
</ol>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130123928518.png" alt="image-20221130123928518"></p>
<ol start="3">
<li>前期做好准备后，到达了关键一步。通过调用DPC合约的claimStakeLp方法，多次取出最低的0.000000000000000001LP来获得奖励。</li>
</ol>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130125826087.png" alt="image-20221130125826087"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function claimStakeLp(address _from ,uint256 Amountwei) public &#123;</span><br><span class="line">        require(Amountwei &gt; 0,&quot;Quantity error&quot;);</span><br><span class="line">        require(_from==msg.sender,&quot;error&quot;);</span><br><span class="line">        require(dpcLp[_from] &gt;= Amountwei ,&quot;Insufficient authorization limit&quot;);</span><br><span class="line">        IERC20(LpContract).transfer(_from,Amountwei);</span><br><span class="line">				// 在这一步，进行奖励的累加，其中还调用了getClaimQuota函数</span><br><span class="line">				// 然而在getClaimQuota内，oldClaimQuota[_from]又重复了一次累加计算</span><br><span class="line">				// 这是导致漏洞的原因</span><br><span class="line">        oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from));</span><br><span class="line"></span><br><span class="line">        dpcLp[_from] = dpcLp[_from].sub(Amountwei);</span><br><span class="line"></span><br><span class="line">        time=currTimeStamp();</span><br><span class="line">        dpcLpTime[_from] = time;</span><br><span class="line"></span><br><span class="line">        dpcLpTotal = dpcLpTotal.sub(Amountwei);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function getClaimQuota(address addr) public view returns (uint256) &#123;</span><br><span class="line">      uint256 ClaimQuota;</span><br><span class="line">      if(dpcAirdrop[addr] &gt; 0 &amp;&amp; dpcLp[addr]&gt;0)&#123;</span><br><span class="line">           uint256 QuotastartTime;</span><br><span class="line">           uint256 limit = 50 * 10**18;</span><br><span class="line">           uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);</span><br><span class="line">           uint256 secondQuota;</span><br><span class="line">           if(getDpcPrice()&gt;0)&#123;</span><br><span class="line">               secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           uint256 limitSecondQuota = limit.div(24*60*60);</span><br><span class="line">           if(secondQuota &gt; limitSecondQuota)&#123;</span><br><span class="line">               secondQuota = limitSecondQuota;</span><br><span class="line">           &#125;</span><br><span class="line">           uint256 nowTime = currTimeStamp();</span><br><span class="line"></span><br><span class="line">           if(dpcLpTime[addr]&gt;ClaimQuotaTime[addr])&#123;</span><br><span class="line">               QuotastartTime = dpcLpTime[addr];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               QuotastartTime = ClaimQuotaTime[addr];</span><br><span class="line">           &#125;</span><br><span class="line">           ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);</span><br><span class="line">           if(ClaimQuota &gt; dpcAirdrop[addr])&#123;</span><br><span class="line">               ClaimQuota = dpcAirdrop[addr];</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">           ClaimQuota = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      // 这里进行了一次相加</span><br><span class="line">      ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]);</span><br><span class="line"></span><br><span class="line">      return ClaimQuota;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.获利后，调用claimDpcAirdrop方法，这次获得奖励约20,602 DPC，后续又兑换为 75,664 BUSD</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130125057699.png" alt="image-20221130125057699"></p>
<p>后续攻击者又重复之前的一些步骤，继续获利。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CDPC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/image-20221130125229810.png" alt="image-20221130125229810"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>合约代码需要进行多次审查</li>
<li>针对DPC中出现的漏洞，最好对每次取出的代币数量进行一定的限制，计算奖励时也不要出现这种多次累加的情况。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/" class="post-title-link" itemprop="url">攻击事件分析｜AurumNodePool合约遭受攻击</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-23 16:15:36 / 修改时间：17:16:49" itemprop="dateCreated datePublished" datetime="2022-11-23T16:15:36+08:00">2022-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2022年11月23日，AurumNodePool合约遭受漏洞攻击。攻击者通过该漏洞获得约50个BNB，大约$14,538.04。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><strong>交易</strong>：<a target="_blank" rel="noopener" href="https://bscscan.com/tx/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782">https://bscscan.com/tx/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782</a></p>
<p><strong>攻击者地址</strong>：0x6903499751f973052155df339116b6c6b24ac24b</p>
<p><strong>攻击合约</strong>：0x3d743b2f760A431CC20047CB5c7758c9a8860D6b</p>
<p><strong>分析工具</strong>：<a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782">https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782</a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>每日奖励值rewardPerDay变量可以随意设置。</p>
<p>可以看代码：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L578">https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L578</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeRewardPerNode</span>(<span class="params">uint256 _rewardPerDay</span>) external &#123;        </span><br><span class="line">        rewardPerDay = _rewardPerDay;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到调用changeRewardPerNode就可以设置rewardPerDay的值，攻击者将这个值设置的非常大。</p>
<p>然后调用claimNodeReward方法，或使用getNodeReward方法计算奖励，结果计算出来的奖励值也非常大，之后攻击者提取了节点奖励。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/image-20221123160822165.png" alt="image-20221123160822165"></p>
<p>getNodeReward：<a target="_blank" rel="noopener" href="https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L504">https://bscscan.com/address/0x70678291bddfd95498d1214be368e19e882f7614#code#L504</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getNodeReward(NodeEntity memory node) internal view returns (uint256) &#123;</span><br><span class="line">        return rewardPerDay * (block.timestamp - node.lastClaimTime) / 86400;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>可以看到getNodeReward里面计算奖励时使用的就是可被利用的rewardPerDay。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E5%A5%96%E5%8A%B1%E8%AE%A1%E7%AE%97%E5%8F%98%E9%87%8F%E5%8F%AF%E6%8E%A7/image-20221123161313087.png" alt="image-20221123161313087"></p>
<p>详细步骤拆分：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>from</th>
<th>to</th>
<th>value</th>
<th>input</th>
<th>out</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>* CALL</td>
<td>0x69（攻击者）</td>
<td>0x3d7(攻击合约)</td>
<td>0</td>
<td>0x0b123036</td>
<td>0x0..2b3c6f033f4a02b65</td>
<td></td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x3d7(攻击合约)</td>
<td>0x73a(AUR token)</td>
<td></td>
<td>{account:0x706(AurumNodePool)}</td>
<td>557774869144434074322370839</td>
<td>查询AurumNodePool中AUR余额</td>
</tr>
<tr>
<td>-changeRewardPerNode</td>
<td>0x3d7(攻击合约)</td>
<td>0x706(AurumNodePool)</td>
<td></td>
<td>{_rewardPerDay:434159898144856792986061626032}</td>
<td>0x</td>
<td>设置AurumNodePool合约中的_rewardPerDay值，这个是日奖励，居然可以任意设置，问题就出在这里</td>
</tr>
<tr>
<td>* claimNodeReward</td>
<td>0x3d7(攻击合约)</td>
<td>0x706(AurumNodePool）</td>
<td></td>
<td>{_creationTime:1669141375}</td>
<td>0x</td>
<td>获取奖励</td>
</tr>
<tr>
<td>-transfer</td>
<td>0x706(AurumNodePool）</td>
<td>0x3d7(攻击合约)</td>
<td></td>
<td>{recipient:0x3d7,amount:557774869144434074322370838}</td>
<td>True</td>
<td>转走奖励</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/23/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">攻击事件分析｜一个公开_transfer攻击分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-23 10:08:00 / 修改时间：10:19:14" itemprop="dateCreated datePublished" datetime="2022-11-23T10:08:00+08:00">2022-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>这个攻击事件只是一个小事件，一次攻击获利不多，不过攻击者将这类型漏洞攻击自动化了，从攻击者的交易记录来看，还是有一些获利的。</p>
<p><strong>交易链接</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92">https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122200317537.png" alt="image-20221122200317537"></p>
<p><strong>攻击者地址</strong>：0xe3c5f54ab7a7a46810b24b272364c418b0151948</p>
<p><strong>攻击合约</strong>：</p>
<p>0x4c8986ed92f6cb908733206821d537927e4dfc29</p>
<p><strong>分析工具</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92">https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92/debugger?trace=0.11">https://dashboard.tenderly.co/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92/debugger?trace=0.11</a></p>
<p><a target="_blank" rel="noopener" href="https://bscscan.com/tx/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92#eventlog">https://bscscan.com/tx/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92#eventlog</a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这次攻击利用了公开的_transfer漏洞，漏洞在WCH token合约内。</p>
<p><a target="_blank" rel="noopener" href="https://bscscan.com/address/0x011e02fd0da512841692279879d6ec49bf74ba7a#code#L632">https://bscscan.com/address/0x011e02fd0da512841692279879d6ec49bf74ba7a#code#L632</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">transferMultiWallet</span>(<span class="params">address sender,address recipient, uint256 amount</span>) external returns (bool) &#123;</span><br><span class="line">    <span class="title function_">_transfer</span>(sender, recipient, amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) internal &#123;</span><br><span class="line">    <span class="built_in">require</span>(sender != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;BEP20: transfer from the zero address&quot;</span>);</span><br><span class="line">    <span class="built_in">require</span>(recipient != <span class="title function_">address</span>(<span class="number">0</span>), <span class="string">&quot;BEP20: transfer to the zero address&quot;</span>);</span><br><span class="line"></span><br><span class="line">    _balances[sender] = _balances[sender].<span class="title function_">sub</span>(amount, <span class="string">&quot;BEP20: transfer amount exceeds balance&quot;</span>);</span><br><span class="line">    _balances[recipient] = _balances[recipient].<span class="title function_">add</span>(amount);</span><br><span class="line">    emit <span class="title class_">Transfer</span>(sender, recipient, amount);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用transferMultiWallet就可以将任意帐户的WCH发送到其他地址去，然后调用了sync强制同步PancakePair WCH-BUSD池中的储备量与余额，导致WCH价格飙升，然后再出售WCH将PancakePair WCH-BUSD池中的BUSD获取完。</p>
<h2 id="攻击步骤分析"><a href="#攻击步骤分析" class="headerlink" title="攻击步骤分析"></a>攻击步骤分析</h2><p>如下：</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122213929496.png" alt="image-20221122213929496"></p>
<p>通过分析工具：<a target="_blank" rel="noopener" href="https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92">https://phalcon.blocksec.com/tx/bsc/0xea49cf1fc32647f7938f80c81097fe75ee88cc0aab347a5d40f2e3832edada92</a></p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122215419126.png" alt="image-20221122215419126"></p>
<p>下面是对具体步骤的详细拆分：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>From</th>
<th>To</th>
<th>Value</th>
<th>Input</th>
<th>Output</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>* CALL</td>
<td>0xe3c(攻击者)</td>
<td>0x4c8(攻击合约)</td>
<td>0.001BNB</td>
<td>0x9eb6f829……（raw data）</td>
<td>0x</td>
<td>猜测调用攻击合约某个方法，并发送0.01BNB用作燃料费</td>
</tr>
<tr>
<td>-staticall</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>0x8da5cb5b</td>
<td>0x15e（WCH token 持有人）</td>
<td>获取WCHtoken的创建者</td>
</tr>
<tr>
<td>-staticall</td>
<td>0x4c8(攻击合约)</td>
<td>0x10e(PancakeRouter)</td>
<td></td>
<td>0xc45a0155</td>
<td>0xca14（Pancake Factory）</td>
<td>获取Pancake Factory地址</td>
</tr>
<tr>
<td>-getPair</td>
<td>0x4c8(攻击合约)</td>
<td>0xca14（Pancake Factory）</td>
<td></td>
<td>{0x011(WCH token), 0xe9(BUSD token)}</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>获取WCH-BUSD交易池</td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{amunt:’0x257’}</td>
<td>435517532569589321744</td>
<td>获取0x257(PancakePair WCH-BUSD)中WCH的余额</td>
</tr>
<tr>
<td>* transferMultiWallet</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{sender:’0x257’，’recipient’:’0x15e’，amount:’435517532569589321734’}</td>
<td>True</td>
<td>通过任意transfer将0x257(PancakePair WCH-BUSD)中WCH的余额留下10个，其余全部转移到0x15e（WCH token 持有人）地址上，其实0x15也可以替换为其余可用地址，不是必定的</td>
</tr>
<tr>
<td>* PancakePair.sync</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td></td>
<td></td>
<td></td>
<td>True</td>
<td>调用0x257(PancakePair WCH-BUSD)合约的sync方法进行同步，让合约储备量和余额（10）保持一致。此时WCH只剩下10，BUSD数量不变，为保证K值，导致WCH价格飙升</td>
</tr>
<tr>
<td>* CALL</td>
<td>0x4c8(攻击合约)</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td></td>
<td>0xff6cae9</td>
<td>0x</td>
<td>调用0x257(PancakePair WCH-BUSD)执行某个方法，目的是确认0x257(PancakePair WCH-BUSD)中WCH和BUSD余额</td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{amount: 0x257(PancakePair WCH-BUSD)}</td>
<td>10</td>
<td>查询0x257(PancakePair WCH-BUSD)中WCH余额，为10</td>
</tr>
<tr>
<td>-balanceOf</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>0xe9(BUSD token)</td>
<td></td>
<td>{amunt: 0x257(PancakePair WCH-BUSD)}</td>
<td>456365713891375952252</td>
<td>查询0x257(PancakePair WCH-BUSD)中BUSD余额，为456365713891375952252</td>
</tr>
<tr>
<td>* balanceOf</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{account: 0x15e(WCH持有者)}</td>
<td>435517532569589321734</td>
<td>查询WCH持有者中WCH余额，为435517532569589321734</td>
</tr>
<tr>
<td>* transferMultiWallet</td>
<td>0x4c8(攻击合约)</td>
<td>0x011(WCH token)</td>
<td></td>
<td>{sender:’0x15e’,’recipient’:’0x15e’’0x257’,amount:’435517532569589321734’}</td>
<td>True</td>
<td>通过任意transfer，将0x15e(WCH持有者)中所有的WCH都发送给0x257(PancakePair WCH-BUSD)，这意味着现在有用户即将进行WCH-BUSD的兑换（swap），接下来就可以调用0x257(PancakePair WCH-BUSD)的swap方法将换取的BUSD兑换到任何地址了。需要注意，当前transfer和接下来的swap一定要在同一笔交易内完成，不可分割，不然其他人也可以通过swap方法转走这一笔BUSD。还值得注意的一点是，池子中的BUSD其实只需要10WCH就可以兑换完的。</td>
</tr>
<tr>
<td>* getAmountOut</td>
<td>0x4c8(攻击合约)</td>
<td>0x10e(PancakeRouter)</td>
<td></td>
<td>{amountIn:435517532569589321734,reserverIn:10,reserverOut:456365713891375952252 }</td>
<td>amountOut:456365713891375952241</td>
<td>查询435517532569589321734WCH可以兑换多少BUSD，可换456365713891375952241</td>
</tr>
<tr>
<td>* PancakePair.swap</td>
<td>0x257(PancakePair WCH-BUSD)</td>
<td>0x4c8(攻击合约)</td>
<td></td>
<td>{amount0Out:0,amount1Out:456365713891375952241,to:0x4c8(攻击合约)}</td>
<td>true</td>
<td>将BUSD兑换到0x4c8(攻击合约)。这里需要了解swap的特性，只要之前有人tranferWCH到Pair内，任何人都可以通过swap转走这笔钱，所以要保证transfer和swap一起</td>
</tr>
</tbody></table>
<p>剩下的步骤就是把获得的BUSD换成BNB，就不做详述了。</p>
<p><img src="/../images/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9C%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80_transfer%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/image-20221122215622414.png" alt="image-20221122215622414"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此类问题的原因还是权限控制没有做好，将原本internal的方法公开了，导致任何人都可以调用原本的内部函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/02/Uniswap%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BD%9CUniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/02/Uniswap%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BD%9CUniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Uniswap系列(二)｜Uniswap的交易与流动性原理详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-02 14:42:29 / 修改时间：15:43:37" itemprop="dateCreated datePublished" datetime="2022-11-02T14:42:29+08:00">2022-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-交易所"><a href="#1-交易所" class="headerlink" title="1.交易所"></a>1.交易所</h2><p>​	传统的中心化交易所，以股票、公司债券等为交易对象的叫证券交易所，以大宗商品(如棉花、小麦等)为交易对象的叫商品交易所。而在Uniswap中，交易对象是虚拟货币。</p>
<p>​	先来说一下中心化交易所是怎么进行交易的：在中心化交易所有一个东西叫做订单簿（order book），它保存了所有的买单、卖单信息。并将合适的买单、卖单撮合成一笔交易。如下表所示就是一个订单薄，一般会同时展示买卖双方的订单情况。</p>
<table>
<thead>
<tr>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>20000</td>
</tr>
<tr>
<td>99.2</td>
<td>10000</td>
</tr>
<tr>
<td>99.1</td>
<td>10000</td>
</tr>
<tr>
<td>86.2</td>
<td>500</td>
</tr>
<tr>
<td>80.1</td>
<td>1</td>
</tr>
</tbody></table>
<p>​	<img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221101175859542.png" alt="image-20221101175859542"></p>
<p>​	如果该交易所足够繁荣，那么只要价格合理，买卖双方的交易会很快匹配到合适的订单。相反，如果平台上的买卖双方不够活跃，这个时候用户发出的买单或买单可能很长时间才会有找到合适的交易方进行交易，就会出现长时间挂单的情况，导致效率低下。为了解决这种问题，就出现了做市商。</p>
<h2 id="2-做市商"><a href="#2-做市商" class="headerlink" title="2.做市商"></a>2.做市商</h2><p>​	做市商是指在传统证券市场上，由具备一定实力（资金足够支持用户大金额交易，因为它要同时承担买方和卖方的角色）和信誉（不能出现机构随意操控市场的情况）的独立证券经营法人作为特许交易商。</p>
<p>​	做市商不断向公众投资者报出某些特定证券的买卖价格，并在该价位上接受公众投资者的买卖要求，以其自有资金和证券与投资者进行证券交易。买卖双方不需等待交易对手出现，只要有做市商出面承担交易对手方既可达成交易。</p>
<p>​	做市商通过做市制度来维持市场的流动性，满足公众投资者的投资需求。做市商通过买卖报价的适当差额来补偿所提供服务的成本费用，并实现一定的利润。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102104721074.png" alt="image-20221102104721074"></p>
<p>​		有了做市商后，卖方挂的单会由做市商给买下来，买家买的单会由做市商卖给买家。也就是说买卖双方不再是直接交易了，实际上买卖双方都在和做市商进行交易。有些人会觉得做市商和庄家一样，其实不是的，做市商是有情怀，他们要去维护市场的稳定繁荣。而庄家可不给你讲什么情怀，他们唯恐天下不乱，就希望市场混乱，好进行高买低卖，以此牟利。做市商给出的买卖价格是双向报价，它会有一个对市场的大概评估，当过于低迷或者是过于火热的时候，超出估值范围，做市商会控制估值维护市场稳定。</p>
<h2 id="3-自动化做市商"><a href="#3-自动化做市商" class="headerlink" title="3.自动化做市商"></a>3.自动化做市商</h2><p>​	而在区块链的世界中，如果要复刻中心化交易所的模式，是有缺陷的。第一点：无法确定做市商有足够的资本。第二点：区块链没有监管机构，无法完全避免做市商监守自盗的可能性。</p>
<p>​	所以Uniswap提出了一种通过智能合约实现自动化做市商（Automated Market Maker，AMM）来与用户进行交易的去中心化交易协议，用户资产完全由自己控制，而智能合约中锁定的做市资产也可公开查看，是一种更安全透明的交易方式。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102105320892.png" alt="image-20221102105320892"></p>
<p>​	从上图可以看到，现在买卖方都只和区块链中的自动做市商智能合约程序进行交互了，自动做市商要实现能够自动和买&#x2F;卖方完成交易，需要满足几个特性：</p>
<ul>
<li>要持有资产，由于要做双向报价，那就是一种代币换取另一种代币，所以要持有两种资产。</li>
<li>资金池要能够充值、提现。</li>
<li>要能根据市场情况自动调整价格。</li>
<li>要能够通过交易赚取利润。</li>
</ul>
<h2 id="4-自动化做市商的实现"><a href="#4-自动化做市商的实现" class="headerlink" title="4.自动化做市商的实现"></a>4.自动化做市商的实现</h2><h3 id="4-1-流动性介绍"><a href="#4-1-流动性介绍" class="headerlink" title="4.1 流动性介绍"></a>4.1 流动性介绍</h3><p>​	Uniswap中有一个重要的概念就是流动资金池，它由两个ERC-20代币（token）储备组成，它就是这一对ERC-20代币的交易场所。</p>
<p>​	在最初，资金池中每个token的余额为0，为了让资金池能够进行交易，需要有一个人存入两种代币作为初始存款，同时存入两种代币的行为叫做提供流动性，这个提供流动性的人人被称为流动性提供者，并且获得流动性池份额（LPS）。而这第一个流动性提供者也是设定资金池初始价格的人。</p>
<p>​	举个栗子🌰：此时要创建一个A、Btoken的池子。流动性提供者小明提供了10000枚A token，1000枚B token的流动性进入流动池。</p>
<p>​	流动池中A、B的价格是通过池子中两种代币的数量比来决定的。直观的理解就是两种代币的总价值是相同的，每次交易完之后由于两种代币的数量会发生变化，相对价格也会变化，价格的调整遵循如下公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x * y = k  (k为常数)</span><br></pre></td></tr></table></figure>

<p>​	x、y代表两种token的数量，此时：k&#x3D;100,000*1000&#x3D;100,000,000。</p>
<p>​	提供流动性后会获得流动性份额LPS，计算的公式是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sqrt</span>(x * y)</span><br></pre></td></tr></table></figure>

<p>​	此时：LPS&#x3D; sqrt(100,000*1000)&#x3D;10000。使用几何平均数计算的好处是可以使LPS在任何时候都不受质押的两种代币的比例影响，因为两种代币在流动性池中的比例可能与市场价格不符。</p>
<p>​	如下图所示，现在质押了10000个A代币，1000个B代币，产生了10000个LPS。现在A:B&#x3D;100:1，也就是说现在100个A代币可以兑换1个B代币。而流动性提供者小明获持有100%的LPS，共10000LPS。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102122324589.png" alt="image-20221102122324589"></p>
<p>​		需要注意的是，在实际情况下，第一次提供流动性时，返回的LPS其实是有调整的，任何流动性池在启用之初都要在零地址中锁定<code>1e-15</code>的LPS。原因是智能合约中LPS的位数是18位，理论上有一种情况，就是初始情况的LPS&#x3D;1，就是最小量即<code>1e-18</code> LPS。如果此时1LPS&#x3D;1000$的话，后续流动性提供者必须要质押价值大于1000$的流动性才可以获得1个LPS，导致添加流动性的成本变高，这是不利于维持交易的流动性的。在Uniswap白皮书中把这种极端情况认为是一种可能的人为攻击，为了提高这种攻击的成本，在新创建流动性池的时候，设置了一个最小流动性值<code>MINIMUM_LIQUIDITY=1e-15=1000</code>，即LPS最小单位的1000倍，任何流动性池在启用之初都要在零地址中锁定<code>1e-15</code>的LPS。所以修订后的图为：</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102125528344.png" alt="image-20221102125528344"></p>
<p>​	在这种机制之下，如果人为把LPS价值提升到1e-18 &#x3D; $100的话，就需要在零地址中锁定价值 $100 * 1e3 &#x3D; $100000 的LPS，这样就极大地提升了攻击成本，而且在通常情况下，1e-15的LPS的价值是很小的，甚至可以忽略，所以修订图中第一次质押后获得的LPS虽然要减少1e-15LPS，但约等于10000不变。当然也会有极端情况，例如Pair中质押的两种代币都没有小数，而且单价很高，那么1e-15LPS的价值还是可以感知到的，不过这种类型的代币也不太适合用Uniswap协议来交易。</p>
<h3 id="4-2-添加-x2F-销毁流动性"><a href="#4-2-添加-x2F-销毁流动性" class="headerlink" title="4.2 添加&#x2F;销毁流动性"></a>4.2 添加&#x2F;销毁流动性</h3><p>​	后续，如果要继续提供流动性，则按新增的流动性等比例增发LPS，假设当前Pool中X的量为x_current，Y的量为y_current，存量LPS为s_current，新增加的流动性中的X为x_add，Y为y_add（通常情况下x_current&#x2F;y_current &#x3D; x_add&#x2F;y_add，即等比例增加流动性），则新增发的LPS为s_add:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_add = <span class="title function_">min</span>(x_add/x_current, y_add/y_current) * s_current</span><br></pre></td></tr></table></figure>

<p>​	比如增加2000个A token，20个B token，那么按照公式计算，会增发200LPS。如果说我要增加2000个A token，30个B token，那么会取min(2000&#x2F;100000，30&#x2F;1000)*10000&#x3D;50&#x3D;200，还是会增发200LPS，另一种多出来B的不会去质押，会返还避免损失。当然，如果直接操作Pair合约没有自己进行校验，可能导致多余的的B不会返还。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102132232247.png" alt="image-20221102132232247"></p>
<p>​	如果要销毁流动性，就会等比例的返还A、B两种token，计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_withdraw = s_remove/s_current * x_current</span><br><span class="line">y_withdraw = s_remove/s_current * y_current</span><br></pre></td></tr></table></figure>

<p>比如现在销毁100LPS，那么就会取的A 共计（100&#x2F;10200）* 102000 &#x3D; 1000，B共计：（100&#x2F;10200）* 1020 &#x3D; 10。此时LPS &#x3D; 10200-100&#x3D;10100。</p>
<p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102133727220.png" alt="image-20221102133727220"></p>
<h3 id="4-3-交易"><a href="#4-3-交易" class="headerlink" title="4.3 交易"></a>4.3 交易</h3><p><img src="/../images/Uniswap%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%8E%E6%B5%81%E5%8A%A8%E6%80%A7%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/image-20221102142719452.png" alt="image-20221102142719452"></p>
<p>​	如上图所示，该流动性池子最开始有100X和1Y，所以初始价格是100个Xtoken，可以兑换1个Ytoken。而价格曲线遵循<code>x*y=k</code>，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x+x_swap) * (y-y_swap) = k</span><br><span class="line">y_swap = y- k/(x+x_swap) = (x_swap*y)/x+x_swap</span><br></pre></td></tr></table></figure>

<p>​	而X、Ytoken的价格也会随着两者数量的变化而发生改变，最终形成一条价格曲线<code>x*y=k</code>。</p>
<p>​	如上图所示，原流动性池中两种代币余额为100 X和1 Y，可认为Y相对X的价格为1 Y &#x3D; 100 X，此时要通过流动性池交易20个X，如果按照当前价格全量交易的话，应该换回 20 &#x2F; 100 &#x3D; 0.2 个Y，而在Uniswap中，每当发生交易时，都会向交易发送者收取 0.3% 的费用。这笔费用在交易完成后按比例分配给池中的所有 LP。所以再减去0.3%的手续费，最后返回0.1994个Y，但实际返回了0.1658个Y，我们来逐步分析一下：</p>
<ol>
<li><p>输入20个X，先扣除0.3%的手续费，即实际交易量为19.94个X。</p>
</li>
<li><p>按照x*y&#x3D;k（k&#x3D;1*100&#x3D;100）的公式进行计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(100+19.94) * (1-y_swap) = 100。</span><br><span class="line">y约为0.1658.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Uniswap pair会给交易者地址返回0.1658个Y，此交易平均交易价格为 1 Y &#x3D; 20 &#x2F; 0.1658 X &#x3D; 120.6273 X，比交易开始时的100要高20%多，主要是因为交易量20个X相对于流动性池的比例较大（20%），相当于大额交易，对价格会产生较大影响，直观的感觉就是市场上有人大量买入Y，从而导致Y的价格上涨，此笔交易之后，交易池中Y相对于X的价格变为了143.8504。</p>
</li>
<li><p>更新流动性池中的余额，虽然交易的时候扣掉了0.3%的手续费，但实际上这个手续费依然会放到流动性池中，作为流动性提供者的收益，因此X更新后的余额还是100 + 20 &#x3D; 120，Y的余额是1 - 0.1658 &#x3D; 0.8342，Liquidity Shares的值不变。随着交易手续费的积累，整个流动性池的总价值在上涨，LPS的总量不变，则LPS的单位价值上涨。</p>
</li>
</ol>
<p>​	由于有手续费的原因，X、Ytoken的数量都在慢慢增多，所以k值其实也不是一直守恒着的，K值其实是在慢慢变大的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380749685">Uniswap深度科普</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.uniswap.org/protocol/V2/introduction">Uniswap v2 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/272241656">合约安全(4):为啥说UniswapK值不那么守恒</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/01/Uniswap%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BD%9C%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/01/Uniswap%E7%B3%BB%E5%88%97(%E4%B8%80)%EF%BD%9C%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Uniswap系列(一)｜介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-01 16:20:20" itemprop="dateCreated datePublished" datetime="2022-11-01T16:20:20+08:00">2022-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-02 15:43:28" itemprop="dateModified" datetime="2022-11-02T15:43:28+08:00">2022-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、什么是Uniswap？"><a href="#一、什么是Uniswap？" class="headerlink" title="一、什么是Uniswap？"></a>一、什么是Uniswap？</h1><hr>
<p>Uniswap 是一个在以太坊上基于智能合约的去中心化交易所，旨在实现数字资产之间的自动兑换​​​​</p>
<h1 id="二、历史"><a href="#二、历史" class="headerlink" title="二、历史"></a>二、历史</h1><hr>
<ul>
<li>2018年11月2日：Uniswap v1版本上线以太坊主网，这是Uniswap推出第一个版本，但是v1版本只能算是一个新型去中心化交易方式的概念验证，可实用性并不强。</li>
<li>2020年5月19日：Uniswap v2版本上线以太坊主网，增加了自由组合交易对、价格预言机、闪贷、最优化交易路径等功能，对v1版本进行了全面的技术升级。</li>
<li>2021年5月5日：Uniswap v3版本上线以太坊主网，提供了集中流动性、多重收费层次、高级价格预言机、流动性预言机等技术升级。核心是提升资本效率。</li>
</ul>
<p>这里简单介绍了一下各个版本历史，后续会有专门的文章来更详细的去介绍他们之间的区别。</p>
<h1 id="三、核心功能"><a href="#三、核心功能" class="headerlink" title="三、核心功能"></a>三、核心功能</h1><hr>
<h2 id="1、交易功能"><a href="#1、交易功能" class="headerlink" title="1、交易功能"></a>1、交易功能</h2><p>Uniswap其实简单来说，就是进行不同代币之间的交换。</p>
<p>在传统金融中，就类似于不同国家的法币的兑换，比如人民币去兑换美元、美元兑日元；而在Uniswap中，可能是ETH兑换DAI，DAI兑换Avae。</p>
<p>与传统金融不同的是，Uniswap可没有银行这种机构，它有的是一个个流动性池子，每个流动性池子中都有两种币（假设为A token、B token），A、B之间可以相互兑换，它们的价格遵循x*y&#x3D;k&#x3D;x’<em>y’（x是A token价格，y是B token价格，k是一个恒定值，x’是新的A token价格，y’是新的B token价格），这个x</em>y&#x3D;k叫恒定乘积做市商，是Uniswap中非常重要的规则。</p>
<p>如果想用C token去换A token，但是并没有C、A token的流动性池子，那么就会生成一条路径，在不同的流动性池子之间进行兑换，C-&gt;……-&gt;B-&gt;A。</p>
<h2 id="2、添加流动性"><a href="#2、添加流动性" class="headerlink" title="2、添加流动性"></a>2、添加流动性</h2><p>在Uniswap中，我们也可以用自己去创建流动性池子，或者为已存在的流动性池子通过流动性（需提供A 、B两种token），这样会成为流动性提供者，并获得LP Token（做市凭证）。</p>
<h2 id="3、闪电贷"><a href="#3、闪电贷" class="headerlink" title="3、闪电贷"></a>3、闪电贷</h2><p>在流动性足够的情况下，可提供借贷服务，但是必须在一个区块内完成的借款和还款的操作。</p>
<h2 id="4、预言机"><a href="#4、预言机" class="headerlink" title="4、预言机"></a>4、预言机</h2><p>预言机就是去咨询代币价格的对象。Uniswap V2开始使用的价格预言机称为 TWAP（Time-Weighted Average Price） ，即时间加权平均价格 。</p>
<p>​</p>
<h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><hr>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380749685">Uniswap深度科普 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1731613743405915605">时隔两年再次回顾DeFi的代表项目—Uniswap</a></p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3960">价格预言机的使用总结（二）：UniswapV2篇</a></p>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ELLEN</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ELLEN</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
