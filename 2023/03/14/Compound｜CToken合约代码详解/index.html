<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Compound的CToken合约当我们在Compound中存入代币时，Compound就会铸造对应的cToken。 CToken合约只是个基类合约，没有构造函数，并且声明了几个抽象的函数，这些抽象函数由上层合约实现。 上层合约分为两种类型：cEther和CERC20，分别处理ETH和ERC20 Token，ETH对应的cEther合约，Erc20对应cErc20合约。 cEther合约是ETH的">
<meta property="og:type" content="article">
<meta property="og:title" content="Compound｜CToken合约代码详解">
<meta property="og:url" content="http://example.com/2023/03/14/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="ELLEN&#39;s BLOG">
<meta property="og:description" content="Compound的CToken合约当我们在Compound中存入代币时，Compound就会铸造对应的cToken。 CToken合约只是个基类合约，没有构造函数，并且声明了几个抽象的函数，这些抽象函数由上层合约实现。 上层合约分为两种类型：cEther和CERC20，分别处理ETH和ERC20 Token，ETH对应的cEther合约，Erc20对应cErc20合约。 cEther合约是ETH的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/image-20230314101931675.png">
<meta property="article:published_time" content="2023-03-14T03:00:54.669Z">
<meta property="article:modified_time" content="2023-03-14T03:04:19.998Z">
<meta property="article:author" content="ELLEN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/image-20230314101931675.png">

<link rel="canonical" href="http://example.com/2023/03/14/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Compound｜CToken合约代码详解 | ELLEN's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ELLEN's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/14/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="ELLEN">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELLEN's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Compound｜CToken合约代码详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 11:00:54 / 修改时间：11:04:19" itemprop="dateCreated datePublished" datetime="2023-03-14T11:00:54+08:00">2023-03-14</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Compound的CToken合约"><a href="#Compound的CToken合约" class="headerlink" title="Compound的CToken合约"></a>Compound的CToken合约</h1><p>当我们在Compound中存入代币时，Compound就会铸造对应的cToken。</p>
<p>CToken合约只是个基类合约，没有构造函数，并且声明了几个抽象的函数，这些抽象函数由上层合约实现。</p>
<p>上层合约分为两种类型：cEther和CERC20，分别处理ETH和ERC20 Token，ETH对应的cEther合约，Erc20对应cErc20合约。</p>
<p>cEther合约是ETH的cToken的交互入口，CErc20Delegator是Erc20的交互入口。在早期版本中，CErc20是Erc20的交互入口，但后来做了调整，CErc20 移除了构造函数，改为了初始化函数，又增加了 CErc20Delegate 作为其上层合约，而且还增加了 CErc20Delegator 来代理 CToken，作为 cToken 的入口合约。</p>
<p><img src="/../images/Compound%EF%BD%9CCToken%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/image-20230314101931675.png" alt="image-20230314101931675"></p>
<p>CToken的主要功能是mint（存款）、redeem（赎回存款）、brorrow（借款）、repayBorrow（还款）、liquidate（清算）。</p>
<h1 id="1-CToken代码详解"><a href="#1-CToken代码详解" class="headerlink" title="1. CToken代码详解"></a>1. CToken代码详解</h1><h2 id="1-1-引入文件"><a href="#1-1-引入文件" class="headerlink" title="1.1 引入文件"></a>1.1 引入文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./ComptrollerInterface.sol&quot;; // Comptroller审计合约借款</span><br><span class="line">import &quot;./CTokenInterfaces.sol&quot;; // cToken接口合约</span><br><span class="line">import &quot;./ErrorReporter.sol&quot;; // 错误报告合约</span><br><span class="line">import &quot;./EIP20Interface.sol&quot;; // EIP20接口合约</span><br><span class="line">import &quot;./InterestRateModel.sol&quot;; // 利率模型合约</span><br><span class="line">import &quot;./ExponentialNoError.sol&quot;; // </span><br></pre></td></tr></table></figure>

<p><strong>ComptrollerInterface.sol</strong></p>
<p>ComptrollerInterface是comptroller合约的方法声明，comptroller合约是一个审计合约，会对一些核心业务进行审计和校验。审计函数主要有：</p>
<ul>
<li>**mintAllowed()**：是否允许存款</li>
<li>**redeemAllowed()**：是否允许取款</li>
<li>**borrowAllow()**：是否允许借款</li>
<li>**repayBorrowAllowed()**：是否允许还款</li>
<li>**liquidateBorrowAllowed()**：是否允许清算</li>
<li>**seizeAllowed()**：是否允许清算抵押物</li>
<li>**transferAllowed()**：是否允许转账</li>
</ul>
<p><strong>EIP20Interface.sol</strong></p>
<p>这个合约声明了Erc20标准的常用方法，比如</p>
<ul>
<li>状态：<code>name()</code> 、<code>symbol() </code>、<code>decimals()</code>、<code>totalSupply() </code>、<code>balanceOf(address owner) </code></li>
<li>授权和代币转移：<code>approve(address spender, uint256 amount)</code>、<code>allowance(address owner, address spender)</code>、<code>transferFrom(address src, address dst, uint256 amount)</code>、<code>transfer(address dst, uint256 amount)</code></li>
<li>事件：<code>Transfer</code>、<code> Approval</code></li>
</ul>
<p><strong>InterestRateModel.sol</strong></p>
<p>这个合约定义了利率模型的接口，但因为声明了一个常量<code>isInterestRateModel</code>用来标明这是一个利率模型合约，所以没用 interface 声明，而用 contract，定义成抽象合约。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: BSD-3-Clause</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @title Compound&#x27;s InterestRateModel Interface</span><br><span class="line">  * @author Compound</span><br><span class="line">  */</span><br><span class="line">abstract contract InterestRateModel &#123;</span><br><span class="line">    // 合约是否是利率模型合约</span><br><span class="line">    bool public constant isInterestRateModel = true;</span><br><span class="line"></span><br><span class="line">    // 获取当前的借款利率</span><br><span class="line">    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);</span><br><span class="line"></span><br><span class="line">		// 获取当前存款利率</span><br><span class="line">    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ExponentialNoError.sol</strong></p>
<p>这个合约实现了一些计算方法，定义了Exp结构体，便于安全的进行精度为1e18的数据运算。</p>
<p><strong>ErrorReporter.sol</strong></p>
<p>跟踪错误代码和故障条件的库。</p>
<h2 id="1-2-初始化函数initialize"><a href="#1-2-初始化函数initialize" class="headerlink" title="1.2 初始化函数initialize"></a>1.2 初始化函数initialize</h2><p>这个方法的作用就是初始化利率、comptroller、利率模型、还有cToken的名称、符号以及精度，还初始化了重入锁变量<code>_notEntered = true;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function initialize(ComptrollerInterface comptroller_, // 审计合约地址</span><br><span class="line">                        InterestRateModel interestRateModel_, // 利率模型地址·</span><br><span class="line">                        uint initialExchangeRateMantissa_, // 初始化汇率</span><br><span class="line">                        string memory name_,</span><br><span class="line">                        string memory symbol_,</span><br><span class="line">                        uint8 decimals_) public &#123;</span><br><span class="line">        // 只能由admin调用此方法，并且这个方法只能调用一次</span><br><span class="line">        require(msg.sender == admin, &quot;only admin may initialize the market&quot;);</span><br><span class="line">        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, &quot;market may only be initialized once&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置初始化利率，初始汇率必须大于零</span><br><span class="line">        initialExchangeRateMantissa = initialExchangeRateMantissa_;</span><br><span class="line">        require(initialExchangeRateMantissa &gt; 0, &quot;initial exchange rate must be greater than zero.&quot;);</span><br><span class="line"></span><br><span class="line">        //设置comptroller，如果_setComptroller返回0，那么代表设置成功</span><br><span class="line">        uint err = _setComptroller(comptroller_);</span><br><span class="line">        require(err == NO_ERROR, &quot;setting comptroller failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化区块数和指数</span><br><span class="line">        accrualBlockNumber = getBlockNumber();</span><br><span class="line">        borrowIndex = mantissaOne;</span><br><span class="line"></span><br><span class="line">        // 设置利率模型</span><br><span class="line">        err = _setInterestRateModelFresh(interestRateModel_);</span><br><span class="line">        require(err == NO_ERROR, &quot;setting interest rate model failed&quot;);</span><br><span class="line"></span><br><span class="line">				// 设置cToken的名称、符号和精确度</span><br><span class="line">        name = name_;</span><br><span class="line">        symbol = symbol_;</span><br><span class="line">        decimals = decimals_;</span><br><span class="line"></span><br><span class="line">        // 初始化重入锁</span><br><span class="line">        _notEntered = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-transfer"><a href="#1-3-transfer" class="headerlink" title="1.3 transfer"></a>1.3 transfer</h2><p>校验：<code>src !== dst</code>； 授权的数量</p>
<p>作用：spender将token从src转移到dst。是 <code>transfer</code> 和<code>transferFrom</code>的内部调用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) &#123;</span><br><span class="line">   return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) &#123;</span><br><span class="line">        // Fail if transfer not allowed </span><br><span class="line">        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert TransferComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not allow self-transfers </span><br><span class="line">        if (src == dst) &#123;</span><br><span class="line">            revert TransferNotAllowed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 	获得授权金额</span><br><span class="line">        uint startingAllowance = 0;</span><br><span class="line">        if (spender == src) &#123;</span><br><span class="line">            startingAllowance = type(uint).max;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startingAllowance = transferAllowances[src][spender];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新余额，检查上下溢出</span><br><span class="line">        uint allowanceNew = startingAllowance - tokens;</span><br><span class="line">        uint srcTokensNew = accountTokens[src] - tokens;</span><br><span class="line">        uint dstTokensNew = accountTokens[dst] + tokens;</span><br><span class="line"></span><br><span class="line">        accountTokens[src] = srcTokensNew;</span><br><span class="line">        accountTokens[dst] = dstTokensNew;</span><br><span class="line">        // 如果是第三方授权，更新授权金额</span><br><span class="line">        if (startingAllowance != type(uint).max) &#123;</span><br><span class="line">            transferAllowances[src][spender] = allowanceNew;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        emit Transfer(src, dst, tokens);</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-transferFrom"><a href="#1-4-transferFrom" class="headerlink" title="1.4 transferFrom"></a>1.4 transferFrom</h2><p>作用：第三方转移token，调用transferTokens方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) &#123;</span><br><span class="line">        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-approve"><a href="#1-5-approve" class="headerlink" title="1.5 approve"></a>1.5 approve</h2><p>可见性：external</p>
<p>返回值：bool</p>
<p>作用：调用者授权给spender数量为amount的token使用权，设置transferAllowances的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint256 amount) override external returns (bool) &#123;</span><br><span class="line">        address src = msg.sender;</span><br><span class="line">        transferAllowances[src][spender] = amount;</span><br><span class="line">        emit Approval(src, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-balanceOfUnderlying"><a href="#1-6-balanceOfUnderlying" class="headerlink" title="1.6 balanceOfUnderlying"></a>1.6 balanceOfUnderlying</h2><p>作用：获取用户的标的资产数量，标的资产也会在交易中产生利息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function balanceOfUnderlying(address owner) override external returns (uint) &#123;</span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateCurrent()&#125;);</span><br><span class="line">        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-7-getAccountSnapshot"><a href="#1-7-getAccountSnapshot" class="headerlink" title="1.7 getAccountSnapshot"></a>1.7 getAccountSnapshot</h2><p>作用：获取用户的余额，以及缓存的汇率。可以更有效地执行流动性检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) &#123;</span><br><span class="line">        return (</span><br><span class="line">            NO_ERROR,</span><br><span class="line">            accountTokens[account],</span><br><span class="line">            borrowBalanceStoredInternal(account),</span><br><span class="line">            exchangeRateStoredInternal()</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-borrowRatePerBlock"><a href="#1-8-borrowRatePerBlock" class="headerlink" title="1.8 borrowRatePerBlock"></a>1.8 borrowRatePerBlock</h2><p>作用：返回当前区块借款利率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function borrowRatePerBlock() override external view returns (uint) &#123;</span><br><span class="line">        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-totalBorrowsCurrent"><a href="#1-9-totalBorrowsCurrent" class="headerlink" title="1.9 totalBorrowsCurrent"></a>1.9 totalBorrowsCurrent</h2><p>作用：返回当前借款总额加上应计利息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function totalBorrowsCurrent() override external nonReentrant returns (uint) &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        return totalBorrows;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-accrueInterest"><a href="#1-10-accrueInterest" class="headerlink" title="1.10 accrueInterest"></a>1.10 accrueInterest</h2><p>作用：计算新利息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function accrueInterest() virtual override public returns (uint) &#123;</span><br><span class="line">        // 检查块是否落后，如果相等代表当前区块已经计算过利息，无需计算，直接返回</span><br><span class="line">        uint currentBlockNumber = getBlockNumber();</span><br><span class="line">        uint accrualBlockNumberPrior = accrualBlockNumber;</span><br><span class="line">        if (accrualBlockNumberPrior == currentBlockNumber) &#123;</span><br><span class="line">            return NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 读取资金池余额，借款总额、总储备金、借款指数</span><br><span class="line">        uint cashPrior = getCashPrior();</span><br><span class="line">        uint borrowsPrior = totalBorrows;</span><br><span class="line">        uint reservesPrior = totalReserves;</span><br><span class="line">        uint borrowIndexPrior = borrowIndex;</span><br><span class="line"></span><br><span class="line">        // 如果borrowRate超过最大借款利率，则错误退出</span><br><span class="line">        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);</span><br><span class="line">        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, &quot;borrow rate is absurdly high&quot;);</span><br><span class="line"></span><br><span class="line">        // 计算自上次统计以来经过的块数 </span><br><span class="line">        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;</span><br><span class="line">				// 区块区间内的单位利息</span><br><span class="line">        Exp memory simpleInterestFactor = mul_(Exp(&#123;mantissa: borrowRateMantissa&#125;), blockDelta);</span><br><span class="line">        // 表示总借款在该区间内产生的总利息</span><br><span class="line">        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);</span><br><span class="line">        // 总利息累加到总借款中</span><br><span class="line">        uint totalBorrowsNew = interestAccumulated + borrowsPrior;</span><br><span class="line">        // 根据储备金将部分利息累加到储备金中</span><br><span class="line">        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp(&#123;mantissa: reserveFactorMantissa&#125;), interestAccumulated, reservesPrior);</span><br><span class="line">        // 累加借款指数</span><br><span class="line">        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);</span><br><span class="line">				// 更新上一次统计区块、借款指数、总借款、储备金</span><br><span class="line">        accrualBlockNumber = currentBlockNumber;</span><br><span class="line">        borrowIndex = borrowIndexNew;</span><br><span class="line">        totalBorrows = totalBorrowsNew;</span><br><span class="line">        totalReserves = totalReservesNew;</span><br><span class="line"></span><br><span class="line">        // We emit an AccrueInterest event </span><br><span class="line">        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);</span><br><span class="line"></span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-11-borrowBalanceCurrent"><a href="#1-11-borrowBalanceCurrent" class="headerlink" title="1.11 borrowBalanceCurrent"></a>1.11 borrowBalanceCurrent</h2><p>获取当前借贷金额</p>
<p>内部调用了borrowBalanceStoredInternal方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function borrowBalanceStored(address account) override public view returns (uint) &#123;</span><br><span class="line">        return borrowBalanceStoredInternal(account);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function borrowBalanceStoredInternal(address account) internal view returns (uint) &#123;</span><br><span class="line">        // Get 获取借贷余额和借贷指数 </span><br><span class="line">        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         // 如果借贷余额为0，那么借贷指数也为0</span><br><span class="line">        if (borrowSnapshot.principal == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 计算新贷款额需要用到利率指数，公式如下:</span><br><span class="line">         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex</span><br><span class="line">         */</span><br><span class="line">        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;</span><br><span class="line">        return principalTimesIndex / borrowSnapshot.interestIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-12-exchangeRateCurrent"><a href="#1-12-exchangeRateCurrent" class="headerlink" title="1.12 exchangeRateCurrent"></a>1.12 exchangeRateCurrent</h2><p>获取当前汇率</p>
<p>有三个函数：exchangeRateCurrent、exchangeRateStored、exchangeRateStoredInternal，逐层调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 返回当前汇率，精度1e18</span><br><span class="line">function exchangeRateCurrent() override public nonReentrant returns (uint) &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        return exchangeRateStored();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function exchangeRateStored() override public view returns (uint) &#123;</span><br><span class="line">        return exchangeRateStoredInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 根据cToken的标的资产去计算汇率，这个函数在计算汇率之前不产生利息</span><br><span class="line">function exchangeRateStoredInternal() virtual internal view returns (uint) &#123;</span><br><span class="line">        uint _totalSupply = totalSupply;</span><br><span class="line">        // 如果总供应量_totalSupply等于0，说明还没有cToken被铸造，此时的汇率等于初始汇率initialExchangeRate</span><br><span class="line">        // 如果总供应量_totalSupply不等于0，汇率等于(totalCash + totalBorrows - totalReserves) / totalSupply，即（资金池余额+总借款-总供储备量）/ 总供应量</span><br><span class="line">        if (_totalSupply == 0) &#123;</span><br><span class="line">            return initialExchangeRateMantissa;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint totalCash = getCashPrior();</span><br><span class="line">            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;</span><br><span class="line">            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;</span><br><span class="line"></span><br><span class="line">            return exchangeRate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-13-mint"><a href="#1-13-mint" class="headerlink" title="1.13 mint"></a>1.13 mint</h2><p>存款，之所以叫 mint，是因为该操作会新增 cToken 数量，即 totalSupply 增加了，就等于挖矿了 cToken。该操作会将用户的标的资产转入 cToken 合约中（数据会存储在代理合约中），并根据最新的兑换率将对应的 cToken 代币转到用户钱包地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 提供标的资产到资金池可以获得cToken</span><br><span class="line">function mintInternal(uint mintAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        mintFresh(msg.sender, mintAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function mintFresh(address minter, uint mintAmount) internal &#123;</span><br><span class="line">				// 会检查是否允许铸造</span><br><span class="line">        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert MintComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //校验资金池区块是否当前最新</span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert MintFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal()&#125;);</span><br><span class="line"></span><br><span class="line">         // cToken的标的资产一定会是Erc20 Token或者是ETH。actualMintAmount是收到的标的资产数量</span><br><span class="line">        uint actualMintAmount = doTransferIn(minter, mintAmount);</span><br><span class="line">				// 获取当前汇率去计算可以铸造的cToken, 公式是：当前存款/汇率</span><br><span class="line">        uint mintTokens = div_(actualMintAmount, exchangeRate);</span><br><span class="line"></span><br><span class="line">         // 更新总供应量和账户余额</span><br><span class="line">        totalSupply = totalSupply + mintTokens;</span><br><span class="line">        accountTokens[minter] = accountTokens[minter] + mintTokens;</span><br><span class="line"></span><br><span class="line">        emit Mint(minter, actualMintAmount, mintTokens);</span><br><span class="line">        emit Transfer(address(this), minter, mintTokens);</span><br><span class="line"></span><br><span class="line">        /* We call the defense hook */</span><br><span class="line">        // unused function</span><br><span class="line">        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-14-redeem"><a href="#1-14-redeem" class="headerlink" title="1.14 redeem"></a>1.14 redeem</h2><p>赎回存款，即用 cToken 换回标的资产，会根据最新的兑换率计算能换回多少标的资产。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 用 cToken 换回标的资产，会根据最新的兑换率计算能换回多少标的资产</span><br><span class="line">function redeemInternal(uint redeemTokens) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        redeemFresh(payable(msg.sender), redeemTokens, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同样是赎回存款的函数，与上一个函数不同的是，该函数指定的是标的资产的数量，会根据兑换率算出需要扣减多少 cToken。</span><br><span class="line">function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        // redeemFresh emits redeem-specific logs on errors, so we don&#x27;t need to</span><br><span class="line">        redeemFresh(payable(msg.sender), 0, redeemAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 用 cToken 换回标的资产</span><br><span class="line">     * @param redeemer 要赎回资产的用户地址</span><br><span class="line">     * @param redeemTokensIn 支付的cToken数量</span><br><span class="line">     * @param redeemAmountIn 要获得的标的资产的数量</span><br><span class="line">     */</span><br><span class="line"> //     </span><br><span class="line">function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal &#123;</span><br><span class="line">				// redeemTokensIn和redeemAmountIn必须有一个为0</span><br><span class="line">        require(redeemTokensIn == 0 || redeemAmountIn == 0, &quot;one of redeemTokensIn or redeemAmountIn must be zero&quot;);</span><br><span class="line"></span><br><span class="line">        /* exchangeRate = invoke Exchange Rate Stored() */</span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal() &#125;);</span><br><span class="line"></span><br><span class="line">        uint redeemTokens; // 赎回使用的cToken数量</span><br><span class="line">        uint redeemAmount; // 获得的标的资产数量</span><br><span class="line"></span><br><span class="line">        // 如果用于赎回的cToken大于0，那么计算数量为redeemTokensIn的cToken可以换回多少标的资产</span><br><span class="line">        // 如果用于赎回的cToken等于0，那么计算赎回数量为redeemAmountIn的标的资产要减去多少cToken</span><br><span class="line">        if (redeemTokensIn &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 通过汇率来计算:cToken * 汇率</span><br><span class="line">             *  redeemAmount = redeemTokensIn x exchangeRateCurrent</span><br><span class="line">             */</span><br><span class="line">            redeemTokens = redeemTokensIn;</span><br><span class="line">            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 公式:标的资产/汇率</span><br><span class="line">             *  redeemTokens = redeemAmountIn / exchangeRate</span><br><span class="line">             *  redeemAmount = redeemAmountIn</span><br><span class="line">             */</span><br><span class="line">            redeemTokens = div_(redeemAmountIn, exchangeRate);</span><br><span class="line">            redeemAmount = redeemAmountIn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查看cToken是否允许赎回</span><br><span class="line">        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert RedeemComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查区块</span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert RedeemFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果资金池余额小于赎回的标的资产，报错</span><br><span class="line">        if (getCashPrior() &lt; redeemAmount) &#123;</span><br><span class="line">            revert RedeemTransferOutNotPossible();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line">        // 更新总供应量和用户cToken余额</span><br><span class="line">        totalSupply = totalSupply - redeemTokens;</span><br><span class="line">        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * We invoke doTransferOut for the redeemer and the redeemAmount.</span><br><span class="line">         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.</span><br><span class="line">         *  On success, the cToken has redeemAmount less of cash.</span><br><span class="line">         *  doTransferOut reverts if anything goes wrong, since we can&#x27;t be sure if side effects occurred.</span><br><span class="line">         */</span><br><span class="line">        doTransferOut(redeemer, redeemAmount);</span><br><span class="line"></span><br><span class="line">        /* We emit a Transfer event, and a Redeem event */</span><br><span class="line">        emit Transfer(redeemer, address(this), redeemTokens);</span><br><span class="line">        emit Redeem(redeemer, redeemAmount, redeemTokens);</span><br><span class="line"></span><br><span class="line">        /* We call the defense hook */</span><br><span class="line">        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-15-borrow"><a href="#1-15-borrow" class="headerlink" title="1.15 borrow"></a>1.15 borrow</h2><p>借款，会根据用户的抵押物来计算可借额度，借款成功则将所借资产从资金池中直接转到用户钱包地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 发送抵押物后可以借出标的资产，borrowAmount是要借出的标的资产的数量</span><br><span class="line">function borrowInternal(uint borrowAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        borrowFresh(payable(msg.sender), borrowAmount);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">function borrowFresh(address payable borrower, uint borrowAmount) internal &#123;</span><br><span class="line">       // 是否允许借款操作</span><br><span class="line">        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert BorrowComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查区块</span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert BorrowFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前余额小于借出数量，则报错</span><br><span class="line">        if (getCashPrior() &lt; borrowAmount) &#123;</span><br><span class="line">            revert BorrowCashNotAvailable();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取该用户总借贷金额</span><br><span class="line">        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);</span><br><span class="line">        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;</span><br><span class="line">        uint totalBorrowsNew = totalBorrows + borrowAmount;</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        // 更新用户借款和资金池总借款数据</span><br><span class="line">        accountBorrows[borrower].principal = accountBorrowsNew;</span><br><span class="line">        accountBorrows[borrower].interestIndex = borrowIndex;</span><br><span class="line">        totalBorrows = totalBorrowsNew;</span><br><span class="line"></span><br><span class="line">        doTransferOut(borrower, borrowAmount);</span><br><span class="line"></span><br><span class="line">        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-16-repayBorrow"><a href="#1-16-repayBorrow" class="headerlink" title="1.16 repayBorrow"></a>1.16 repayBorrow</h2><p>还款，当指定还款金额为 -1 时，则表示全额还款，包括所有利息，否则，则会存在利息没还尽的可能，因为每过一个区块就会产生新的利息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 还款，当指定还款金额为 -1 时，则表示全额还款</span><br><span class="line">function repayBorrowInternal(uint repayAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        repayBorrowFresh(msg.sender, msg.sender, repayAmount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        repayBorrowFresh(msg.sender, borrower, repayAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 还款</span><br><span class="line">     * @param payer 收质押物地址</span><br><span class="line">     * @param borrower 借款人地址</span><br><span class="line">     * @param repayAmount 还款金额，为 -1 时，则表示全额还款</span><br><span class="line">     * @return (uint) the actual repayment amount.</span><br><span class="line">     */</span><br><span class="line">    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) &#123;</span><br><span class="line">        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert RepayBorrowComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert RepayBorrowFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	// 借款人借款金额</span><br><span class="line">        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);</span><br><span class="line"></span><br><span class="line">        // 还款金额为 -1 时，则表示全额还款</span><br><span class="line">        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line">        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);</span><br><span class="line"></span><br><span class="line">        // 更新借款数据 </span><br><span class="line">        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;</span><br><span class="line">        uint totalBorrowsNew = totalBorrows - actualRepayAmount;</span><br><span class="line"></span><br><span class="line">        accountBorrows[borrower].principal = accountBorrowsNew;</span><br><span class="line">        accountBorrows[borrower].interestIndex = borrowIndex;</span><br><span class="line">        totalBorrows = totalBorrowsNew;</span><br><span class="line"></span><br><span class="line">        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);</span><br><span class="line"></span><br><span class="line">        return actualRepayAmount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-17-liquidateBorrow"><a href="#1-17-liquidateBorrow" class="headerlink" title="1.17 liquidateBorrow"></a>1.17 liquidateBorrow</h2><p>清算，任何人都可以调用此函数来担任清算人，直接借款人、还款金额和清算的 cToken 资产，清算时，清算人帮借款人代还款，并得到借款人所抵押的等值+清算奖励的 cToken 资产。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @notice 调用者清算借款，扣押的抵押品转移给清算人</span><br><span class="line">     * @param borrower 被清算的借款人</span><br><span class="line">     * @param cTokenCollateral 被清算的资金池</span><br><span class="line">     * @param repayAmount 偿还的标的资产的数额</span><br><span class="line">     */</span><br><span class="line">function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant &#123;</span><br><span class="line">        accrueInterest();</span><br><span class="line">        uint error = cTokenCollateral.accrueInterest();</span><br><span class="line">        if (error != NO_ERROR) &#123;</span><br><span class="line">            revert LiquidateAccrueCollateralInterestFailed(error);</span><br><span class="line">        &#125;</span><br><span class="line">        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal &#123;</span><br><span class="line">        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert LiquidateComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (accrualBlockNumber != getBlockNumber()) &#123;</span><br><span class="line">            revert LiquidateFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) &#123;</span><br><span class="line">            revert LiquidateCollateralFreshnessCheck();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (borrower == liquidator) &#123;</span><br><span class="line">            revert LiquidateLiquidatorIsBorrower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (repayAmount == 0) &#123;</span><br><span class="line">            revert LiquidateCloseAmountIsZero();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (repayAmount == type(uint).max) &#123;</span><br><span class="line">            revert LiquidateCloseAmountIsUintMax();</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">				// 实际偿还金额actualRepayAmount</span><br><span class="line">        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);</span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line"></span><br><span class="line">        // 计算被质押物数量，借款人质押的数量必须大于等于计算出来的实际数量</span><br><span class="line">        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);</span><br><span class="line">        require(amountSeizeError == NO_ERROR, &quot;LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED&quot;);</span><br><span class="line"></span><br><span class="line">        require(cTokenCollateral.balanceOf(borrower) &gt;= seizeTokens, &quot;LIQUIDATE_SEIZE_TOO_MUCH&quot;);</span><br><span class="line">				</span><br><span class="line">				// 如果质押物就是当前cToken，那么调用seizeInternal()</span><br><span class="line">				// 如果质押物不是当前cToken，那么调用cTokenCollateral.seize()</span><br><span class="line">        if (address(cTokenCollateral) == address(this)) &#123;</span><br><span class="line">            seizeInternal(address(this), liquidator, borrower, seizeTokens);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, &quot;token seizure failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     * @notice 将抵押品代币(该市场)转移给清算人</span><br><span class="line">     * @dev 除非在清算过程中被另一个cToken调用，否则将失败。使用msg.sender很关键，作为借用的cToken，而不是参数</span><br><span class="line">     * @param liquidator The account receiving seized collateral</span><br><span class="line">     * @param borrower 质押人</span><br><span class="line">     * @param seizeTokens 被质押的cToken</span><br><span class="line">     * @return 返回0就表示成功</span><br><span class="line">     */</span><br><span class="line">    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) &#123;</span><br><span class="line">        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);</span><br><span class="line"></span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @notice 发送质押物给清算人.</span><br><span class="line">     * @param seizerToken 质押物地址</span><br><span class="line">     * @param liquidator 清算人，接收质押物地址</span><br><span class="line">     * @param borrower 借款人</span><br><span class="line">     * @param seizeTokens 质押物数量</span><br><span class="line">     **/</span><br><span class="line">     </span><br><span class="line">    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal &#123;</span><br><span class="line">        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);</span><br><span class="line">        if (allowed != 0) &#123;</span><br><span class="line">            revert LiquidateSeizeComptrollerRejection(allowed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (borrower == liquidator) &#123;</span><br><span class="line">            revert LiquidateSeizeLiquidatorIsBorrower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 更新借款人数据和清算人数据、汇率、储备金</span><br><span class="line">         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens</span><br><span class="line">         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens</span><br><span class="line">         */</span><br><span class="line">        uint protocolSeizeTokens = mul_(seizeTokens, Exp(&#123;mantissa: protocolSeizeShareMantissa&#125;));</span><br><span class="line">        uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;</span><br><span class="line">        Exp memory exchangeRate = Exp(&#123;mantissa: exchangeRateStoredInternal()&#125;);</span><br><span class="line">        uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);</span><br><span class="line">        uint totalReservesNew = totalReserves + protocolSeizeAmount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /////////////////////////</span><br><span class="line">        // EFFECTS &amp; INTERACTIONS</span><br><span class="line">        // (No safe failures beyond this point)</span><br><span class="line">        totalReserves = totalReservesNew;</span><br><span class="line">        totalSupply = totalSupply - protocolSeizeTokens;</span><br><span class="line">        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;</span><br><span class="line">        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;</span><br><span class="line"></span><br><span class="line">        /* Emit a Transfer event */</span><br><span class="line">        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);</span><br><span class="line">        emit Transfer(borrower, address(this), protocolSeizeTokens);</span><br><span class="line">        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-18-一些状态变量含义"><a href="#1-18-一些状态变量含义" class="headerlink" title="1.18 一些状态变量含义"></a>1.18 一些状态变量含义</h2><p>exchange rate 汇率</p>
<p>borrow interest rate 借款利率</p>
<p>accrualBlockNumber：上次更新利息的区块数</p>
<p>totalSupply 与cToken数量有关</p>
<p>accountTokens[redeemer]记录用户的cToken数量</p>
<p>totalCash 、totalBorrows 、 totalReserves都与标资产有关</p>
<h1 id="二、其他"><a href="#二、其他" class="headerlink" title="二、其他"></a>二、其他</h1><p>本文章创作时：Latest commit <a target="_blank" rel="noopener" href="https://github.com/compound-finance/compound-protocol/commit/a3214f67b73310d547e00fc578e8355911c9d376">a3214f6</a> on Jun 7, 2022</p>
<p>仓库链接：<a target="_blank" rel="noopener" href="https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol">https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/2618#CToken">https://learnblockchain.cn/article/2618#CToken</a></p>
<p><a target="_blank" rel="noopener" href="https://www.defidaonews.com/media/6662323">https://www.defidaonews.com/media/6662323</a></p>
<p><a target="_blank" rel="noopener" href="https://u.naturaldao.io/be/chapter5/5.8%20DeFi%20%E5%80%9F%E8%B4%B7%E5%B9%B3%E5%8F%B0%20Compound">https://u.naturaldao.io/be/chapter5/5.8%20DeFi%20%E5%80%9F%E8%B4%B7%E5%B9%B3%E5%8F%B0%20Compound</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/17/%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%EF%BD%9CPlatypus%E9%81%AD%E9%81%87%E9%97%AA%E7%94%B5%E8%B4%B7%EF%BC%8C%E6%8D%9F%E5%A4%B1$900%E4%B8%87/" rel="prev" title="攻击事件分析｜Platypus遭遇闪电贷，损失$900万">
      <i class="fa fa-chevron-left"></i> 攻击事件分析｜Platypus遭遇闪电贷，损失$900万
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Compound%E7%9A%84CToken%E5%90%88%E7%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">Compound的CToken合约</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-CToken%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">1. CToken代码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%BC%95%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 引入文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0initialize"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 初始化函数initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-transfer"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 transfer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-transferFrom"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 transferFrom</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-approve"><span class="nav-number">2.5.</span> <span class="nav-text">1.5 approve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-balanceOfUnderlying"><span class="nav-number">2.6.</span> <span class="nav-text">1.6 balanceOfUnderlying</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-getAccountSnapshot"><span class="nav-number">2.7.</span> <span class="nav-text">1.7 getAccountSnapshot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-borrowRatePerBlock"><span class="nav-number">2.8.</span> <span class="nav-text">1.8 borrowRatePerBlock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-totalBorrowsCurrent"><span class="nav-number">2.9.</span> <span class="nav-text">1.9 totalBorrowsCurrent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-accrueInterest"><span class="nav-number">2.10.</span> <span class="nav-text">1.10 accrueInterest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-borrowBalanceCurrent"><span class="nav-number">2.11.</span> <span class="nav-text">1.11 borrowBalanceCurrent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-exchangeRateCurrent"><span class="nav-number">2.12.</span> <span class="nav-text">1.12 exchangeRateCurrent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-mint"><span class="nav-number">2.13.</span> <span class="nav-text">1.13 mint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-redeem"><span class="nav-number">2.14.</span> <span class="nav-text">1.14 redeem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-15-borrow"><span class="nav-number">2.15.</span> <span class="nav-text">1.15 borrow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-16-repayBorrow"><span class="nav-number">2.16.</span> <span class="nav-text">1.16 repayBorrow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-17-liquidateBorrow"><span class="nav-number">2.17.</span> <span class="nav-text">1.17 liquidateBorrow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-18-%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89"><span class="nav-number">2.18.</span> <span class="nav-text">1.18 一些状态变量含义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-number">3.</span> <span class="nav-text">二、其他</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ELLEN"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">ELLEN</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ELLEN</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
